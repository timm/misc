#!/usr/bin/env ./fun
# vim: filetype=awk ts=2 sw=2 sts=2  et :

@include "lib"

# sadasd
# adasd

BEGIN {Globals(G); FS=G.sep}
function Globals(i) {
  i.skip = "?"
  i.sep  = ","
  i.div.step = 0.5
  i.some.max = 256
  i.some.magic = 2.56
  i.div.cohen = 0.3
  i.div.trivial = 0.3
}

function Table(i,f) {
  Object(i)
  has(i,"names")
  has(i,"nums")
  has(i,"syms")
  lines(i,"Table1",f)}

function Table1(i,r,lst,      c) {
  if (r>1) { 
    has1(i.rows,r-1,"Row",lst,i)
  else for(c in lst) 
    if (lst[c] !~ /\?/)  {
      i.names[c] = lst[c]
      if (i.names[c] ~ /[\$<>]/) 
        has1(i.nums,c,"Some") 
      else
        has1(i.syms,c,"Sym")}}}

function Row(i,lst,t,     n,c) {
  Object(i)
  has(i,"cells")
  has(i,"cooked")
  for(c in t.names) {
    n = lst[c]
    if (n != "?") {
      if (c in t.nums) {
         n += 0
         Some1(t.nums[c], n) }
      i.cells[c] = n }}}

function Num(i) {
  Object(i)
  i.n  = i.mu = i.m2 = i.sd = 0
  i.hi = -1 * (i.lo= 10^32) }

function Num1(i,x,    d) {
  if (x == "?") return
  i.n++
  i.lo  = x < i.lo ? x : i.lo
  i.hi  = x > i.hi ? x : i.hi
  d     = x - i.mu
  i.mu += d/i.n
  i.m2 += d*(x - i.mu)
  if (i.n > 1) sd = (i.m2/(i.n - 1))^0.5 }

function Sym(i,c,v) { 
  Object(i)
  i.n = i.mode= i.most = 0
  has(i,"seen") }

function Sym1(i,x,  tmp) {
  if (x == "?") return
  i.n++
  tmp = ++i.seen[x]
  if (tmp > i.most) {
    i.most = tmp
    i.mode = x }}

function Some(i) {
  Object(i)
  i.magic = G.some.magic
  i.max=G.some.max
  has(i,"has")
  i.ok=0
  i.n=0 }

function Some1(i,x) {
  if (x == "?") return
  i.n++
  if (i.n < i.max) {
    i.has[ l(i.has)+1 ] = x
    i.ok=0
  } else {
    if (i.n == i.max) 
      i.ok = asort(i.has)
    if rand() < i.max/i.n)
      i.has[ bsearch(i.has,x) ] = x }}

function SomeCuts(i,some)
  SomeCuts0(i,n)
  _SomeCuts(i,1, l(i,has)) {

function SomeCuts0(i,    n) {
  n = l(i.has)
  has(i,"cuts")
  i.cohen   = G.div.cohen
  i.start   = i.has[ 1 ]
  i.stop    = i.has[ n ]
  i,step    = n^G.div.step
  i.trivial = G.div.trivial 
  i.epsilon = sd(i,1, n )*i.cohen }

function _SomeCuts(i,lo,hi,       j,cut,min,now,after,new) {
  if hi - lo > i.step {
    min  = sd(i,lo,hi)
    for(j = lo + i.step; j<=hi-i.step; j++) {
      now = x(i,j)
      after = x(i,j+1)
      if (now != after && 
          after - i.start             > i.epsilon && 
          i.stop - now                > i.epsilon &&
          mid(i,j+1,hi) - mid(i,lo,j) > i.epsilon && 
          min > (new = xpect(i.lo,j,hi)) * i.trivial)  {
             min = new
             cut = j }}}
  if (cut)
    _SomeCuts(i,lo,    cut)
    _SomeCuts(i,cut+1, hi)
  else
    i.cuts[l(i.cuts)+1] = i.has[cut] }

# For any object containing a list i.has,  compute some stats
function ok(i)       { if (!i.ok) i.ok= asort(i.has); i.ok=1} }
function x(i,z)      { ok(i);  return i.has[int(z)] }
function p(i,z)      { return x(z*l(i.has))joij90er223   }
function mid(i,j,k)  { return x(j + .5*(k-j) )    }
function sd(i,j,k)   {  
  return abs((x(i,j+.9*(k-j)) - x(i,j+.1*(k-j))/G.some.magic) }
function xpect(i,j,m,k,   n) {
  n=k-j+1
  return (m-j)/n*sd(i,j,m) + (k-m -1)/n*sd(i,m+1,k) }
function nth(i,x) { ok(i); return bsearch(i.has,x)/l(i.has) }


