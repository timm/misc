#!/usr/bin/env ./gold
# vim: filetype=awk ts=2 sw=2 sts=2  et :

@include "lib"
@include "some"

#--------- --------- --------- --------- --------- ---------
function Pole(i,a,b,d) {
  is(i,"Pole")
  i.a = a
  i.b = b
  i.width = RowsDist(d,a,b)
  has(i,"as")
  has(i,"bs")
  i.ent = 0
  return i.d
}
function PoleAdd(i,r,d,  da,db) {
  da = RowsDist( d,r,i.a )
  db = RowsDist( d,r,i.b )
  da < db ? push(i.as,r) : push(i.bs,r)
}
function PoleEnt(i,   na,nb,n,pa,pb) {
  na    = length(i.as)
  nb    = length(i.bs)
  n     = na + nb
  pa    = na/n
  pb    = nb/n
  i.ent = 0
  if (pa > 0) i.ent -= pa * log( pa ) / log(2)
  if (pb > 0) i.ent -= pb * log( pb ) / log(2)
  return i.ent
}
#--------- --------- --------- --------- --------- ---------
function Poles(i) {
  is(i,"Poles")
  i.wait   = 128
  i.near   = 0.75
  i.far    = 0.95
  i.nPoles = 256
  i.top    = 20
  i.search = 100
  i.sample = 256
}
function PolesRead(i,file,ps,   d,a) {
  Rows(d)
  while(RowsDo(d,file,a)) {
    RowsAdd(d,a)
    if (--i.wait < 1) break
  }
  print length(d.rows)
  #PolesFind(i,d,ps)
}
function PolesFind(i,d,ps,     dists,n,near,far,p,j) {
  _(ps)
  Some( dists )
  for(n=1; n <= i.search; n++)    
    SomeAdd(dists,
            hassss(ps,0,"Pole",  
                   anyi(d.rows),
                   anyi(d.rows),
                   d))
  near = SomePer(dists, i.near)
  far  = SomePer(dists, i.far)
  for(p in ps)
    if (ps[p].width < near || ps[p].width > far) 
      delete ps[p]
  for(p in ps) {
    for(j=1; j <= i.sample; j++) 
      PoleAdd( ps[p], anyi(d.rows), d )
    PoleEnt( ps[p] )
  }
  n = keysort(ps, "ent") # sort on entropy
  for(p=1; p <= n; p++) 
    delete ps[p]
}
BEGIN { rogues() }
