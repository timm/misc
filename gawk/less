#!/usr/bin/env ./morse
# vim: filetype=awk ts=2 sw=2 sts=2  et :

BEGIN {ME.dot = sprintf("%c",46) }
#--------- --------- --------- -------- -------- --------- ---------
# oo support
func List(i)          { split("",i,"") }
func zap(i,k)         { i[k][0]; List(i[k])} 
func is(i,k)          { iss(i,k,"Object") }
func iss(  i,k,p)     { ME.isa[k]=p; @p(i)    ; i.is=k; i.id = ++ME.id}
func isss( i,k,p,a)   { ME.isa[k]=p; @p(i,a)  ; i.is=k; i.id = ++ME.id}
func issss(i,k,p,a,b) { ME.isa[k]=p; @p(i,a,b); i.is=x; i.id = ++ME.id}

func has( i,k,f)         { f=f?f:"List"; zap(i,k); @f(i[k]) }
func hass(i,k,f,a)       {               zap(i,k); @f(i[k],a) }
func hasss(i,k,f,a,b)    {               zap(i,k); @f(i[k],a,b) }
func hassss(i,k,f,a,b,c) {               zap(i,k); @f(i[k],a,b,c) }

func how(i,f,   g,k) {
  k=i.is
  do { g = k f
       if (g in FUNCTAB) return g
       k = ME.isa[k]
  } while(k)
  print "#E> failed method lookup: ["f"]"
  exit 2
}
#--------- --------- --------- -------- -------- --------- ---------
# utils

func oo(x,p,pre,      j,txt) {
  txt = pre ? pre : (p MY.dot)
  ooSortOrder(x)
  for(j in x)  {
    if (isarray(x[j]))   {
      print(txt j"" )
      oo(x[j],"","|  " pre)
    } else
      print(txt j (x[j]==""?"": ": " x[j])) }
}
func ooSortOrder(x, j) {
  for (j in x)
    return PROCINFO["sorted_in"] = \
      typeof(j + 1)=="number" ? "@ind_num_asc" : "@ind_str_asc" 
}
func csv(f,a,     b4, g,txt) {
  f = f ? f : "-"             
  g = gettxt < f
  if (g< 0) { print "#E> Missing f ["f"]"; exit 1 } # file missing
  if (g==0) { close(f) ; return 0 }       # end of file                   
  txt = b4 $0                             # combine with prior
  gsub("([ \t]|#.*)/", "", txt)           # kill whitespace,comments    
  if (!txt)       { return csv(f,a,txt) } # skip blanks
  if (txt ~ /,$/) { return csv(f,a,txt) } # continue txt into next
  split(txt, a, ",")                      # split on "," into "a"
  return 1
}

#--------- --------- --------- -------- -------- --------- ---------
# unit testing

function rogues(    s) {
  for(s in SYMTAB) 
    if (s ~ /^[A-Z][a-z]/) print "Global " s
  for(s in SYMTAB) 
    if (s ~ /^[_a-z]/) print "Rogue: " s
}
function tests(what, all,   one,a,i,n) {
  n = split(all,a,",")
  print "\n#--- " what " -----------------------"
  for(i=1;i<=n;i++) { 
    one = a[i]; @one(one) }
  rogues()
}
BEGIN {
  D.test.epsilon = 0.0001
}
function is(f,got,want,   epsilon,     ok) {
  if (typeof(want) == "number") {
     epsilon = epsilon ? epsilon : MY.test.epsilon
     ok = abs(want - got)/(want + 10^-32)  < epsilon
  } else
     ok = want == got
  if (ok) 
    print "#TEST:\tPASSED\t" f "\t" want "\t" got 
  else 
    print "#TEST:\tFAILED\t" f "\t" want "\t" got 
}
#--------- --------- --------- -------- -------- --------- ---------
# my stuff
BEGIN {
  MY.num="\\$"
  MY.less="<"
  MY.more=">"
  MY.klass="!"
  MY.goal=   "[" MY.less MY.more MY.klass "]"
  MY.numeric="[" MY.less MY.more MY.num   "]"
  MY.skip="\\?" 
}

shared Add(i,v)
shared Dec(i,v)
shared Var(i)
shared Mid(i)

#--------- --------- --------- -------- -------- --------- ---------
class Col(i,txt,pos) {
  is(i,"Col")
  i.n     = 0
  i.txt   = txt
  i.pos   = pos
  i.goal  = txt ~ MY.goal
  i.klass = text ~ MY.klass
  i.w     = txt ~ MY.less ? -1 : 1}
}

#--------- --------- --------- -------- -------- --------- ---------
class Num(i,txt,pos) { 
  isss(i,"Num","Col",txt,pos)
  i.mu = i.m2 = i.sd = 0
  i.lo = 10^32 
  i.hi = -1*i.lo 
}
function _Var(i) { return i.sd }
function _Mid(i) { return i.mu }


func _Add(i,v,    d) {
  if (v ~ MY.skip) return v
  v += 0
  i.n++
  i.lo  = v < i.lo ? v : i.lo
  i.hi  = v > i.hi ? v : i.hi
  d     = v - i.mu
  i.mu += d/i.n
  i.m2 += d*(v - i.mu)
  i.sd  = _Sd(i)
  return v 
}
func _Sd(i) {
  if (i.m2 < 0) return 0
  if (i.n < 2)  return 0
  return  (i.m2/(i.n - 1))^0.5 
}
func _Dec(i,v, d) {
  if (i.n < 1)  return v
  if (v ~ MY.skip) return v
  i.n  -= 1
  d     = v - i.mu
  i.mu -= d/i.n
  i.m2 -= d*(v - i.mu)
  i.sd  = _Sd(i)
  return v
}

#--------- --------- --------- -------- -------- --------- ---------
class Sym(i,txt,pos) { 
  isss(i,"Sym","Col",txt,pos)
  i.mode=""
  i.most=0
  has(i,"seen") 
}
function _Var(i) { return _Ent(i) }
function _Mid(i) { return i.mode  }

func _Add(i,v,  tmp) {
  if (v ~ MY.skip) return v
  i.n++
  tmp = ++i.seen[v]
  if (tmp > i.most) { i.most = tmp; i.mode = v }
  return v 
}
func _Dec(i,v) {
  if (v ~ MY.skip) return v
  if (v in i.seen && i.seen[v] > 0) { i.n--; i.seen[v]-- }
}
func _Ent(i,   p,e,k) {
  for(k in i.seen) {
    p  = i.seen[k]/i.n
    e -= p*log(p)/log(2)
  }
  return e
}  

#--------- --------- --------- -------- -------- --------- ---------
class Row(i) {
  is(i,"Row")
  has(i,"cells")
  has(i,"ranges"
}

#--------- --------- --------- -------- -------- --------- ---------
class Table(i) {
  is(i,"Table")
  has(i,"use")
  has(i,"rows")
  has(i,"cols")
  i.klass = ""
}
func _Empty(i) (i) { return length(i.cols) == 0 }

func _Uses(i,a,       c,j) {
  for(j=1;j<=length(a);j++) 
    if(a[j] ~ MY.skip)
      i.use[++c]=j
}
func _Columns(i,a,       c) { 
  for(c in a) 
    hasss(i.cols, c, 
          a[c] ~ MY.numeric ? "Num" : "Sym"
          a[c], pos)
}
func _Row(i,a,  r,c,x) {
  r = length(i.rows) + 1
  has(i.rows, r, "Row")
  for(c in a) 
    i.rows[r].cells[c] = Add(i.cols[c], a[c])
}
func _Read(i,file,    a,b) {
  while(csv(file,a)) {
    if (_Empty(i))
      _Use(i,a)
    for(j in i.use) 
      b[j] = a[ i.use[j] ]
    _Empty(i) ? _Columns(i,b) : _Row(i,b) 
  }
}   

# func twice(    a,n,f) {
#   f="csv.awk"
#   while(n=csv(a,f)) print 1,n,a[1]
#   while(n=csv(a,f)) print 2,n,a[1]
# }
# 
# BEGIN { twice() }


BEGIN {
 print ("xasdas" ~ MY.num ) 
 print ("?" ~ MY.skip ) 
}
