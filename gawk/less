#!/usr/bin/env ./morse
# vim: filetype=awk ts=2 sw=2 sts=2  et :

BEGIN {THE.dot = sprintf("%c",46) }
#--------- --------- --------- -------- -------- --------- ---------
# oo support
func List(i)          { split("",i,"") }
func Object(i)        { List(i); i.id = ++THE.id }
func zap(i,k)         { i[k][0]; List(i[k])} 
func is(i,k)          { isa(i,k,"Object") }
func isa(  i,k,p)     { THE.isa[k]=p; @p(i)    ; i.is=k }
func isas( i,k,p,a)   { THE.isa[k]=p; @p(i,a)  ; i.is=k }
func isass(i,k,p,a,b) { THE.isa[k]=p; @p(i,a,b); i.is=k }

func has( i,k,f)         { f=f?f:"List"; zap(i,k); @f(i[k]) }
func hass(i,k,f,a)       {               zap(i,k); @f(i[k],a) }
func hasss(i,k,f,a,b)    {               zap(i,k); @f(i[k],a,b) }
func hassss(i,k,f,a,b,c) {               zap(i,k); @f(i[k],a,b,c) }

func how(k,f,   g) {
  while(k) {
    g = k f
    if (g in FUNCTAB) return g
    k = THE.isa[k]
  }
  print "#E> failed method lookup: ["f"]"
  exit 2
}
#--------- --------- --------- -------- -------- --------- ---------
# utils
func o(a,   s,sep,j) {
  s=sep=""
  for(j in a) {
    s= s sep a[j]
    sep=", "
  }
  print s
}
func oo(x,p,pre,      j,txt) {
  txt = pre ? pre : (p MY.dot)
  ooSortOrder(x)
  for(j in x)  {
    if (isarray(x[j]))   {
      print(txt j"" )
      oo(x[j],"","|  " pre)
    } else
      print(txt j (x[j]==""?"": ": " x[j])) }
}
func ooSortOrder(x, j) {
  for (j in x)
    return PROCINFO["sorted_in"] = \
      typeof(j + 1)=="number" ? "@ind_num_asc" : "@ind_str_asc" 
}
func csv(f,a,     b4, g,txt) {
  f = f ? f : "-"             
  g = getline < f
  if (g< 0) { print "#E> Missing f ["f"]"; exit 1 } # file missing
  if (g==0) { close(f) ; return 0 }       # end of file                   
  txt = b4 $0                             # combine with prior
  gsub(/[ \t]+/,"",txt)
  if (txt ~ /,$/) { return csv(f,a,txt) } # continue txt into next
  sub(/#.*/, "", txt)                    # kill whitespace,comments    
  if (!txt)       { return csv(f,a,txt) } # skip blanks
  split(txt, a, ",")                      # split on "," into "a"
  return 1
}

#--------- --------- --------- -------- -------- --------- ---------
# unit testing

function rogues(    s) {
  for(s in SYMTAB) 
    if (s ~ /^[A-Z][a-z]/) print "Global " s
  for(s in SYMTAB) 
    if (s ~ /^[_a-z]/) print "Rogue: " s
}
function tests(what, all,   one,a,i,n) {
  n = split(all,a,",")
  print "\n#--- " what " -----------------------"
  for(i=1;i<=n;i++) { 
    one = a[i]; @one(one) }
  rogues()
}
BEGIN {
  D.test.epsilon = 0.0001
}
function ok(f,got,want,   epsilon,     good) {
  epsilon = epsilon ? epsilon : MY.test.epsilon
  if (typeof(want) == "number") 
    good = abs(want - got)/(want + 10^-32)  < epsilon
  else
    good = want == got;
  print "#TEST:\t"(good?"PASSED":"FAILED") "\t" f "\t" want "\t" got 
}
#--------- --------- --------- -------- -------- --------- ---------
# my stuff
BEGIN {
  MY.num="\\$"
  MY.less="<"
  MY.more=">"
  MY.klass="!"
  MY.goal=   "[" MY.less MY.more MY.klass "]"
  MY.numeric="[" MY.less MY.more MY.num   "]"
  MY.skip="\\?" 
}

shared Add(i,v)
shared Dec(i,v)
shared Var(i)
shared Mid(i)

#--------- --------- --------- -------- -------- --------- ---------
func Col(i,txt,pos) {
  is(i,"Col")
  i.n     = 0
  i.txt   = txt
  i.pos   = pos
  i.goal  = txt ~ MY.goal
  i.klass = text ~ MY.klass
  i.w     = txt ~ MY.less ? -1 : 1
}

#--------- --------- --------- -------- -------- --------- ---------
func Num(i,txt,pos) { 
  isass(i,"Num","Col",txt,pos)
  i.mu = i.m2 = i.sd = 0
  i.lo = 10^32 
  i.hi = -1*i.lo 
}
func NumVar(i) { return i.sd }
func NumMid(i) { return i.mu }

function NumAdd(i,v,    d) {
  if (v ~ MY.skip) return v
  v += 0
  i.n++
  i.lo  = v < i.lo ? v : i.lo
  i.hi  = v > i.hi ? v : i.hi
  d     = v - i.mu
  i.mu += d/i.n
  i.m2 += d*(v - i.mu)
  i.sd  = NumSd(i)
  return v 
}

func NumSd(i) {
  if (i.m2 < 0) return 0
  if (i.n < 2)  return 0
  return  (i.m2/(i.n - 1))^0.5 
}
func NumDec(i,v, d) {
  if (i.n < 1)  return v
  if (v ~ MY.skip) return v
  i.n  -= 1
  d     = v - i.mu
  i.mu -= d/i.n
  i.m2 -= d*(v - i.mu)
  i.sd  = NumSd(i) 
  return v
}

#--------- --------- --------- -------- -------- --------- ---------
func Sym(i,txt,pos) { 
  isass(i,"Sym","Col",txt,pos)
  i.mode=""
  i.most=0
  has(i,"seen") 
}
function SymVar(i) { return SymEnt(i) }
function SymMid(i) { return i.mode  }

func SymAdd(i,v,  tmp) {
  if (v ~ MY.skip) return v
  i.n++
  tmp = ++i.seen[v]
  if (tmp > i.most) { i.most = tmp; i.mode = v }
  return v 
}
func SymDec(i,v) {
  if (v ~ MY.skip) return v
  if (v in i.seen && i.seen[v] > 0) { i.n--; i.seen[v]-- }
}
func SymEnt(i,   p,e,k) {
  for(k in i.seen) {
    p  = i.seen[k]/i.n
    e -= p*log(p)/log(2)
  }
  return e
}  

#--------- --------- --------- -------- -------- --------- ---------
function  Row(i) {
  is(i,"Row")
  has(i,"cells")
  has(i,"ranges")
}

#--------- --------- --------- -------- -------- --------- ---------
function Rows(i) {
  is(i,"Rows")
  has(i,"rows")
  has(i,"cols")
  i.klass = ""
}
func RowsEmpty(i) { return length(i.cols) == 0 }

func RowsUses(i,a,use,       n,j) {
  for(j=1;j<=length(a);j++) 
    if(a[j] ~ THE.skip)
      use[++n]=j;
}
func RowsAddCols(i,a,       c) { 
  for(c in a) 
    hasss(i.cols, c, 
          a[c] ~ MY.numeric ? "Num" : "Sym",
          a[c], pos)
}
func RowsAdd(i,a,  r,c,x) {
  r = length(i.rows) + 1
  has(i.rows, r, "Row")
  for(c in a) 
    print c "[" i.cols[c].it "]"
    #print how(i.cols[c],"Add")
    #i.rows[r].cells[c] = Add(i.cols[c], a[c])
}
func RowsRead(i,file,    a,b,use) {
  while(csv(file,a)) {
    if (RowsEmpty(i))
      RowsUses(i,a,use);
    for(j in use) 
      b[j] = a[ use[j] ];
    o(b)
    RowsEmpty(i) ? RowsAddCols(i,b) :  RowsAdd(i,b) 
  }
}   

func _rows(    i,d) {
  d=THE.dot
  Rows(i); RowsRead(i, d d "/data/weather" d "csv")
  oo(i) 
}
BEGIN {_rows()}
