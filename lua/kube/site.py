#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
build_docs.py: Generates an educational website from a source Python script.

This script analyzes a given Python file, extracts information about its structure
(classes, methods, example functions), and generates a series of Markdown files
that form an educational website. The content includes code overviews, explanations
of Software Engineering (SE) and Artificial Intelligence (AI) concepts,
tutorials for example functions, and license information.

It is designed to be called with parameters specifying the input script,
output directory, and other configuration details.
"""

import os
import ast
import re
import argparse
import textwrap
import json # For storing lists as strings in prompt.txt

# --- Master Parameterized Prompt (to be written to prompt.txt) ---
# This is the template that was used to guide the generation of this script.
# It's included here so 'prompt.txt' can be self-referential.
MASTER_PARAMETRIZED_PROMPT_TEMPLATE = """
Your task is to generate a Python script, hereafter referred to as `{OUTPUT_PYTHON_SCRIPT_NAME}` (e.g., `generate_website.py`). This script, when executed, will create an educational website. The website will consist of multiple Markdown files and one text file. The content for these files must be derived from the analysis of an input Python script, specified by `{INPUT_SCRIPT_PATH}` (e.g., `kube.py`).

**Input Parameters for this Task (to be provided to you, the LLM generating `{OUTPUT_PYTHON_SCRIPT_NAME}`):**

* `{INPUT_SCRIPT_PATH}`: The path to the Python script to be analyzed (e.g., "data/source/kube.py").
* `{EXAMPLE_FUNCTION_PREFIX}`: The prefix used to identify example functions in the input script (e.g., "eg__").
* `{SE_CONCEPTS_LIST}`: A list of Software Engineering concepts to be explained in `se.md` (e.g., `["Python fundamentals", "OOP", "CLI", "File Handling", "Modularity", "Testing"]`).
* `{AI_CONCEPTS_LIST}`: A list of Artificial Intelligence concepts to be explained in `ai.md` (e.g., `["Statistical Measures", "Data Normalization", "Distance Metrics", "Clustering", "LSH", "Multi-objective Optimization", "XAI", "Active Learning"]`).
* `{COPYRIGHT_YEAR}`: The copyright year for the license file (e.g., "2025").
* `{COPYRIGHT_HOLDER}`: The copyright holder for the license file (e.g., "Tim Menzies <timm@ieee.org>").
* `{OUTPUT_PYTHON_SCRIPT_NAME}`: The name of the Python script to be generated (e.g., `generate_website.py`).
* `{OUTPUT_DIR}`: The directory where the generated website files should be saved (e.g., `output_website/`).
* `{HOME_PAGE_NAME}`: The name of the main landing page, often a README (e.g., `README.md`).

**Overall LLM Instructions for this task (when you generate `{OUTPUT_PYTHON_SCRIPT_NAME}`):**

1.  **Primary Output:** Your *only* output should be the complete Python code for `{OUTPUT_PYTHON_SCRIPT_NAME}`.
2.  **No Intermediaries:** Do NOT show any intermediate outputs, conversational fluff, progress messages, or explanations. Just output the final Python file contents directly as a single code block.
3.  **Input Script Analysis:** All generated Markdown content must be based on the analysis of the script found at `{INPUT_SCRIPT_PATH}`. Code snippets for illustration should come from this script.

**`{OUTPUT_PYTHON_SCRIPT_NAME}` Script Specifications:**

1.  **File Generation:** The Python script must generate the following files within the `{OUTPUT_DIR}`:
    * `{HOME_PAGE_NAME}`: A landing page (content can be a brief welcome and links).
    * `Install.md`: An installation guide page (will initially only contain the navigation bar).
    * `code.md`: Documents the structure of the script at `{INPUT_SCRIPT_PATH}`.
    * `se.md`: Explains Software Engineering concepts from the `{SE_CONCEPTS_LIST}`, illustrated with examples from `{INPUT_SCRIPT_PATH}`.
    * `ai.md`: Explains Artificial Intelligence concepts from the `{AI_CONCEPTS_LIST}`, illustrated with examples from `{INPUT_SCRIPT_PATH}`.
    * `tutorial.md`: Provides tutorials for functions in `{INPUT_SCRIPT_PATH}` that start with `{EXAMPLE_FUNCTION_PREFIX}`.
    * `license.md`: Contains the MIT License text.
    * `prompt.txt`: Contains the master parameterized prompt text used to generate `{OUTPUT_PYTHON_SCRIPT_NAME}`, followed by the specific parameter values used for the current website generation run.

2.  **Target Audience & Tone (for the website content generated by `{OUTPUT_PYTHON_SCRIPT_NAME}`):**
    * Audience: Graduate students with no specific prior background in the AI/SE topics covered.
    * Tone: Friendly, informative, concise, and very NOT verbose.

3.  **Navigation Bar:**
    * Add the following Markdown navigation bar at the top of `{HOME_PAGE_NAME}`, `Install.md`, `code.md`, `se.md`, `ai.md`, `tutorial.md`, and `license.md`:
        `[{home}]({HOME_PAGE_NAME}) | [install](Install.md) | [why se](se.md) | [ai](ai.md) | [code](code.md) | [tut](tutorial.md) | [&copy;](license.md) | [regen](prompt.txt)`
        `---`

4.  **Content for `{HOME_PAGE_NAME}`:**
    * Include the navigation bar.
    * A brief welcome message.
    * Optionally, a table of contents or brief descriptions of the other pages.

5.  **Content for `Install.md`:**
    * Include the navigation bar.
    * (Initially, no other content is required for this page beyond the navigation bar. The script should create the file with just the navbar.)

6.  **Content for `code.md` ("Code Overview"):**
    * Reflect over all classes in the script at `{INPUT_SCRIPT_PATH}`.
    * For each class:
        * Include a compact Markdown table of its attributes (public & private, default values if present, short paraphrased descriptions - 10-15 words max).
        * Group methods into conceptual protocols (e.g., `core_behavior`, `initialization`, `data_management`, `statistics_query`, `distance_calculation`, `clustering_projection`). Infer sensible, reusable names.
        * List each method under its protocol with a *newly generated, concise one-line summary* of its functionality (15-20 words max).

7.  **Content for `se.md` ("Software Engineering Concepts") and `ai.md` ("Artificial Intelligence Concepts"):**
    * These pages should provide detailed (yet concise) explanations of concepts from `{SE_CONCEPTS_LIST}` and `{AI_CONCEPTS_LIST}` respectively.
    * **"Terms to watch for":** At the start of each page, under a heading like `## Terms to watch for`, provide an alphabetized list of the key technical terms from the respective `{SE_CONCEPTS_LIST}` or `{AI_CONCEPTS_LIST}` that are introduced and explained within the main content of *that specific page*. The list should only contain the terms themselves.
    * **Content Body:** Elaborate on each concept from the provided lists. Include illustrative Python code snippets from `{INPUT_SCRIPT_PATH}` using Markdown syntax highlighting (```python ... ```). Reference protocol names from `code.md` where relevant.
    * **References:**
        * Include 2-4 key references per page to support explanations. Each reference definition should be on its own line.
        * Where relevant and possible, include papers by "Tim Menzies". Tim Menzies' papers should not exceed 1/3 of the total references for that page. (LLM generating `{OUTPUT_PYTHON_SCRIPT_NAME}`: Use general well-known texts or placeholder citations if specific live search for Menzies papers is not feasible, but ensure this instruction is part of the prompt content that `{OUTPUT_PYTHON_SCRIPT_NAME}` produces for `prompt.txt`).
        * Format references using standard Markdown footnote syntax: inline references like `[^1]`, `[^2]`, etc., and their definitions at the end of the document, each on a new line, like:
            ```markdown
            [^1]: Author, A. B. (Year). *Title of work*. Source.
            [^2]: AnotherAuthor, C. D. (Year). *Another Title*. Another Source.
            ```

    * **Review Questions:** At the end of each page, include **10 review questions** suitable for exams, related to the concepts discussed.

8.  **Content for `tutorial.md` ("Tutorials"):**
    * Iterate through each function found in `{INPUT_SCRIPT_PATH}` whose name starts with `{EXAMPLE_FUNCTION_PREFIX}`.
    * For each such function:
        * **Section Header:** Use the function name (e.g., `## Tutorial: \`{EXAMPLE_FUNCTION_PREFIX}the\``).
        * **Purpose & Concepts:** Clearly explain its purpose and the specific SE/AI concepts it demonstrates, linking to ideas in `se.md` and `ai.md`.
        * **Code with comments:** Display the Python code for the function. The LLM (generating `{OUTPUT_PYTHON_SCRIPT_NAME}`) must instruct the Python script to **add new, detailed educational comments** directly within this code block to clarify each step or important logic, targeting the specified graduate student audience. Ensure correct f-string escaping within the generated code (e.g., `print(f"  {{col_obj}}")` to produce `print(f"  {col_obj}")` in the tutorial markdown).
        * **Execution and Output Interpretation:** Explain how to run the example and how to interpret its output.
        * **Links to `code.md`:** Mention relevant class protocols from `code.md` used by the example.
        * **Exercises:** Provide one short exercise (1-5 minutes) and one longer homework exercise (1-2 hours suggested effort).
    * The `{OUTPUT_PYTHON_SCRIPT_NAME}` script should aim to fully flesh out tutorials for common examples (e.g., those related to configuration, data loading, basic processing). For very numerous or complex `{EXAMPLE_FUNCTION_PREFIX}` functions, it can provide a structural placeholder or a more summarized tutorial, clearly indicating that these would be filled similarly.

9.  **Content for `license.md`:**
    * Include the standard MIT License text.
    * The copyright line should be: `Copyright (c) {COPYRIGHT_YEAR} {COPYRIGHT_HOLDER}`.

10. **Content for `prompt.txt`:**
    * The `{OUTPUT_PYTHON_SCRIPT_NAME}` script should write the following to `prompt.txt`:
        * The full text of this master parameterized prompt (the one you are currently reading).
        * A clear separator (e.g., `---`).
        * A section titled "Parameters Used for This Website Generation:" followed by a list of all the input parameters (e.g., `{INPUT_SCRIPT_PATH}`, `{EXAMPLE_FUNCTION_PREFIX}`, etc.) and their actual values used during the execution of `{OUTPUT_PYTHON_SCRIPT_NAME}` that generated the current set of website files. For example:
            ```
            ---
            **Parameters Used for This Website Generation:**

            * `INPUT_SCRIPT_PATH`: [Actual value used, e.g., "./scripts/kube.py"]
            * `EXAMPLE_FUNCTION_PREFIX`: [Actual value used, e.g., "eg__"]
            * `SE_CONCEPTS_LIST`: [Actual value used]
            * `AI_CONCEPTS_LIST`: [Actual value used]
            * `COPYRIGHT_YEAR`: [Actual value used]
            * `COPYRIGHT_HOLDER`: [Actual value used]
            * `OUTPUT_PYTHON_SCRIPT_NAME`: [Actual value used]
            * `OUTPUT_DIR`: [Actual value used]
            * `HOME_PAGE_NAME`: [Actual value used]
            ---
            ```

**Final `{OUTPUT_PYTHON_SCRIPT_NAME}` Script Structure:**

* The script should take parameters like `{INPUT_SCRIPT_PATH}`, `{EXAMPLE_FUNCTION_PREFIX}`, etc., ideally via command-line arguments (e.g., using `argparse`).
* Use helper functions within the Python script to generate content for each file.
* A `main()` function should orchestrate the calls to these helper functions and write the files to the `{OUTPUT_DIR}`.
* Ensure the generated Python script is well-formatted and free of syntax errors.
* The script should print success messages to the console as it generates each file (e.g., "Successfully generated code.md in {OUTPUT_DIR}").

---
**Source `{INPUT_SCRIPT_PATH}` content will be provided by the user in the chat history when invoking this parameterized prompt.**
---
"""

# --- Global Variables & Constants ---
# These will be populated by command-line arguments
ARGS = None

# --- Helper Functions for AST Parsing and Code Analysis ---

def get_node_source(source_code_str, node):
    """
    Extracts the source code of an AST node.
    Relies on ast.get_source_segment if available (Python 3.8+),
    otherwise falls back to line numbers which might be less precise for multi-line statements.
    """
    if hasattr(ast, 'get_source_segment'):
        try:
            # ast.get_source_segment needs the compiled source, not just string
            # However, for individual nodes, it's often easier to use line numbers
            # if the full source string is available.
            # Let's try with line numbers first as it's more robust for snippets.
            source_lines = source_code_str.splitlines(True) # Keep line endings
            start_line = node.lineno -1
            end_line = getattr(node, 'end_lineno', start_line) # end_lineno might be None
            if end_line is None: end_line = start_line # safety for nodes without end_lineno
            
            # Ensure end_line is not before start_line
            if end_line < start_line: end_line = start_line

            # Handle cases where end_lineno might point to the start of the next line for single-line nodes
            # or where it's not available. A simple heuristic:
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
                # For blocks, try to capture until the dedent or end of file
                block_lines = [source_lines[start_line]]
                base_indent = len(source_lines[start_line]) - len(source_lines[start_line].lstrip())
                for i in range(start_line + 1, len(source_lines)):
                    line = source_lines[i]
                    current_indent = len(line) - len(line.lstrip())
                    if current_indent <= base_indent and line.strip(): # Dedent or same level non-empty line
                        break
                    block_lines.append(line)
                return "".join(block_lines)
            else: # For simpler statements, rely on lineno and end_lineno more directly
                 # This is still tricky without full parsing context.
                 # ast.get_source_segment is better if it can be made to work reliably.
                 # For now, a simpler line-based extraction:
                if end_line >= len(source_lines): end_line = len(source_lines) -1
                return "".join(source_lines[start_line : end_line + 1])

        except Exception as e:
            # Fallback if ast.get_source_segment fails or line numbers are tricky
            # print(f"Warning: Could not get source segment for node {type(node)}: {e}")
            pass # Fall through to basic line number extraction

    # Basic fallback using line numbers (less accurate for multi-line expressions)
    if hasattr(node, 'lineno'):
        source_lines = source_code_str.splitlines()
        start = node.lineno - 1
        end = getattr(node, 'end_lineno', start + 1)
        if end is None or end < start : end = start + 1 # Ensure end is valid
        return "\n".join(source_lines[start:end])
    return f"# Source for {type(node).__name__} could not be extracted."


def parse_input_script(filepath, example_function_prefix):
    """
    Parses the input Python script and extracts information about classes,
    methods, and example functions.
    """
    try:
        with open(filepath, "r", encoding="utf-8") as source_file:
            source_code = source_file.read()
    except FileNotFoundError:
        print(f"Error: Input script '{filepath}' not found.")
        return None
    except Exception as e:
        print(f"Error reading input script '{filepath}': {e}")
        return None

    try:
        tree = ast.parse(source_code)
    except SyntaxError as e:
        print(f"Error: Could not parse Python script '{filepath}'. Syntax error: {e}")
        return None
        
    parsed_data = {"classes": [], "example_functions": []}

    for node in tree.body:
        if isinstance(node, ast.ClassDef):
            class_info = {"name": node.name, "docstring": ast.get_docstring(node) or "", "attributes": [], "methods": []}
            
            # Class-level attributes (e.g., SOME_CONST = 10)
            for item in node.body:
                if isinstance(item, ast.Assign):
                    for target in item.targets:
                        if isinstance(target, ast.Name):
                            default_val_str = "Dynamic/Complex"
                            try:
                                if isinstance(item.value, ast.Constant): # Python 3.8+
                                    default_val_str = repr(item.value.value)
                                elif isinstance(item.value, (ast.Num, ast.Str, ast.Bytes, ast.NameConstant)): # Older Python
                                    if isinstance(item.value, ast.Num): default_val_str = repr(item.value.n)
                                    elif isinstance(item.value, ast.Str): default_val_str = repr(item.value.s)
                                    elif isinstance(item.value, ast.Bytes): default_val_str = repr(item.value.s)
                                    elif isinstance(item.value, ast.NameConstant): default_val_str = repr(item.value.value)
                                else: # Fallback for more complex assignments
                                    # Attempt to reconstruct simple assignments
                                    val_source = get_node_source(source_code, item.value)
                                    if val_source and len(val_source.splitlines()) == 1 and len(val_source) < 50:
                                        default_val_str = val_source.strip()
                            except Exception:
                                pass # Keep "Dynamic/Complex"
                            
                            class_info["attributes"].append({
                                "name": target.id,
                                "default": default_val_str,
                                "type": "class",
                                "doc": "" # Class attributes usually don't have individual docstrings here
                            })
            
            # Methods and __init__ attributes
            for item in node.body:
                if isinstance(item, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    method_info = {
                        "name": item.name,
                        "args": [arg.arg for arg in item.args.args],
                        "docstring": ast.get_docstring(item) or ""
                    }
                    class_info["methods"].append(method_info)

                    if item.name == "__init__":
                        # Attributes assigned in __init__ (self.attr = ...)
                        for stmt in item.body:
                            if isinstance(stmt, ast.Assign):
                                for target in stmt.targets:
                                    if isinstance(target, ast.Attribute) and \
                                       isinstance(target.value, ast.Name) and \
                                       target.value.id == 'self':
                                        
                                        attr_name = target.attr
                                        # Check if already listed as class attribute
                                        if any(a['name'] == attr_name and a['type'] == 'class' for a in class_info["attributes"]):
                                            continue

                                        default_val_str = "Set in __init__"
                                        # Try to get default from __init__ params
                                        try:
                                            arg_index = [a.arg for a in item.args.args].index(attr_name, 1) # after self
                                            num_defaults = len(item.args.defaults)
                                            num_args_no_self = len(item.args.args) -1
                                            
                                            # Defaults are for trailing arguments
                                            # Example: def __init__(self, a, b=1, c=2)
                                            # args: [self, a, b, c], defaults: [1, 2]
                                            # default_idx for 'b' is arg_index(2)-1 - (num_args_no_self(3) - num_defaults(2)) = 1 - 1 = 0
                                            # default_idx for 'c' is arg_index(3)-1 - (num_args_no_self(3) - num_defaults(2)) = 2 - 1 = 1
                                            
                                            idx_in_defaults = (arg_index - 1) - (num_args_no_self - num_defaults)

                                            if 0 <= idx_in_defaults < num_defaults:
                                                default_node = item.args.defaults[idx_in_defaults]
                                                if isinstance(default_node, ast.Constant):
                                                    default_val_str = repr(default_node.value)
                                                elif isinstance(default_node, (ast.Num, ast.Str, ast.Bytes, ast.NameConstant)):
                                                    if isinstance(default_node, ast.Num): default_val_str = repr(default_node.n)
                                                    elif isinstance(default_node, ast.Str): default_val_str = repr(default_node.s)
                                                    # ... and so on for Bytes, NameConstant
                                                else:
                                                    val_source = get_node_source(source_code, default_node)
                                                    if val_source and len(val_source.splitlines()) == 1 and len(val_source) < 50:
                                                        default_val_str = val_source.strip()
                                                    else:
                                                        default_val_str = "Complex default"
                                        except ValueError: # attr_name not in __init__ args, or complex assignment
                                            pass
                                        except Exception:
                                            pass # Error getting default

                                        class_info["attributes"].append({
                                            "name": attr_name,
                                            "default": default_val_str,
                                            "type": "instance",
                                            "doc": "" # Instance attrs usually don't have separate docstrings here
                                        })
            parsed_data["classes"].append(class_info)

        elif isinstance(node, ast.FunctionDef) and node.name.startswith(example_function_prefix):
            func_source = get_node_source(source_code, node)
            if not func_source or func_source.startswith("# Source for"): # If extraction failed
                 func_source = f"# Could not reliably extract source for {node.name}.\n# Please refer to the original file."
            
            parsed_data["example_functions"].append({
                "name": node.name,
                "args": [arg.arg for arg in node.args.args],
                "docstring": ast.get_docstring(node) or "",
                "code": func_source.strip()
            })
            
    return parsed_data

def get_attribute_description(attr_name, class_name, docstring=""):
    """Generates a short description for an attribute."""
    if docstring: # Prefer docstring if available (though not common for attrs directly)
        return docstring.split('.')[0][:80] # First sentence, max length
    
    base_desc = f"Represents the {attr_name.replace('_', ' ')} of a {class_name} object."
    if "config" in attr_name or "setting" in attr_name:
        base_desc = f"Configuration setting for {attr_name.replace('_', ' ')} in {class_name}."
    elif "data" in attr_name or "records" in attr_name or "items" in attr_name:
        base_desc = f"Stores data, such as {attr_name.replace('_', ' ')}, for {class_name}."
    elif "path" in attr_name or "file" in attr_name:
        base_desc = f"File path or handle related to {attr_name.replace('_', ' ')} for {class_name}."
    elif "count" in attr_name or "num" in attr_name:
        base_desc = f"A counter or number representing {attr_name.replace('_', ' ')}."
    return textwrap.shorten(base_desc, width=80, placeholder="...")


def get_method_summary(method_name, class_name, docstring=""):
    """Generates a concise one-line summary for a method."""
    if docstring: # Prefer first line of docstring
        first_line = docstring.splitlines()[0].strip()
        return textwrap.shorten(first_line, width=100, placeholder="...")

    action = "Performs"
    if method_name.startswith("get_") or method_name.startswith("is_") or method_name.startswith("has_") or method_name.startswith("to_"):
        action = "Retrieves, checks, or converts"
    elif method_name.startswith("set_") or method_name.startswith("add_") or method_name.startswith("load_") or method_name.startswith("process_"):
        action = "Sets, adds, loads, or processes"
    elif method_name == "__init__":
        return f"Initializes a new instance of the `{class_name}` class."
    
    summary = f"{action} the {method_name.replace('_', ' ')} operation for `{class_name}`."
    return textwrap.shorten(summary, width=100, placeholder="...")


def infer_protocol(method_name):
    """Infers a conceptual protocol for a method based on its name."""
    name = method_name.lower()
    if name == "__init__": return "Initialization"
    if "load" in name or "read" in name or "fetch" in name: return "Data Loading & Input"
    if "save" in name or "write" in name or "export" in name: return "Data Saving & Output"
    if "process" in name or "transform" in name or "normalize" in name or "clean" in name: return "Data Processing & Transformation"
    if "add" in name or "update" in name or "remove" in name or "set_" in name : return "Data Management & Modification"
    if "get_" in name or "is_" in name or "has_" in name or "to_" in name : return "Data Access & Query"
    if "stat" in name or "summary" in name or "metric" in name or "eval" in name: return "Statistics & Evaluation"
    if "dist" in name or "similar" in name: return "Distance & Similarity"
    if "cluster" in name or "group" in name or "segment" in name: return "Clustering & Grouping"
    if "plot" in name or "visualize" in name or "show" in name: return "Visualization"
    if name.startswith("_") and not name.startswith("__"): return "Internal Helpers"
    if name.startswith("__") and name.endswith("__") and name not in ["__init__", "__repr__", "__str__", "__lt__", "__eq__", "__iter__", "__next__", "__len__"]:
        return "Special Dunder Methods"
    return "Core Logic & Behavior"


# --- Content Generation Functions ---

def generate_nav_bar(home_page_name):
    """Generates the standard Markdown navigation bar."""
    return f"[{home_page_name.split('.')[0]}]({home_page_name}) | [install](Install.md) | [why se](se.md) | [ai](ai.md) | [code](code.md) | [tut](tutorial.md) | [&copy;](license.md) | [regen](prompt.txt)\n---\n"

def generate_home_md(home_page_name, output_python_script_name):
    """Generates content for the home page."""
    content = generate_nav_bar(home_page_name)
    content += f"# Welcome to the Documentation for `{ARGS.input_script_path}`\n\n"
    content += f"This website provides an educational overview of the Python script `{ARGS.input_script_path}`. "
    content += "It has been automatically generated by the `{output_python_script_name}` script.\n\n"
    content += "Navigate using the links above to explore:\n"
    content += "- **Install**: (Placeholder for installation instructions)\n"
    content += "- **Why SE**: Key Software Engineering concepts found in the code.\n"
    content += "- **AI**: Relevant Artificial Intelligence concepts.\n"
    content += "- **Code**: An overview of the script's classes and methods.\n"
    content += "- **Tut**: Tutorials for example functions.\n"
    content += "- **&copy;**: License information.\n"
    content += "- **Regen**: The prompt used to generate the documentation generator itself.\n\n"
    return content

def generate_install_md(home_page_name):
    """Generates content for Install.md."""
    content = generate_nav_bar(home_page_name)
    content += "# Installation Guide\n\n"
    content += "(This page is a placeholder for installation instructions related to the analyzed script.)\n"
    return content

def generate_code_md(parsed_data, home_page_name):
    """Generates content for code.md."""
    content = generate_nav_bar(home_page_name)
    content += f"# Code Overview (`{ARGS.input_script_path}`)\n\n"
    content += f"This document provides an overview of the classes and their structure within `{ARGS.input_script_path}`.\n\n"

    if not parsed_data or not parsed_data["classes"]:
        content += "No class information extracted from the input script.\n"
        return content

    for class_info in parsed_data["classes"]:
        content += f"## Class: `{class_info['name']}`\n\n"
        if class_info['docstring']:
            content += f"_{class_info['docstring'].strip()}_\n\n"
        
        if class_info["attributes"]:
            content += "### Attributes\n\n"
            content += "| Attribute | Default Value | Scope | Description (10-15 words max) |\n"
            content += "|-----------|---------------|-------|-----------------------------------|\n"
            for attr in sorted(class_info["attributes"], key=lambda x: x['name']): # Sort for consistency
                desc = get_attribute_description(attr['name'], class_info['name'], attr.get('doc', ''))
                scope = "Class" if attr['type'] == "class" else "Instance"
                default_val_str = attr['default']
                if len(default_val_str) > 30: default_val_str = textwrap.shorten(default_val_str, width=30, placeholder="...")
                content += f"| `{attr['name']}` | `{default_val_str}` | {scope} | {desc} |\n"
            content += "\n"
        else:
            content += "This class has no explicitly defined attributes in the parsed data.\n\n"

        if class_info["methods"]:
            content += "### Methods by Protocol\n\n"
            protocols = {}
            for method in sorted(class_info["methods"], key=lambda x: x['name']): # Sort for consistency
                protocol_name = infer_protocol(method['name'])
                if protocol_name not in protocols:
                    protocols[protocol_name] = []
                protocols[protocol_name].append(method)
            
            # Sort protocols, with "Initialization" first if present
            sorted_protocol_names = sorted(protocols.keys())
            if "Initialization" in sorted_protocol_names:
                sorted_protocol_names.insert(0, sorted_protocol_names.pop(sorted_protocol_names.index("Initialization")))

            for protocol_name in sorted_protocol_names:
                content += f"#### Protocol: `{protocol_name}`\n\n"
                for method in protocols[protocol_name]:
                    summary = get_method_summary(method['name'], class_info['name'], method['docstring'])
                    args_str = ", ".join(method['args'])
                    content += f"- **`{method['name']}({args_str})`**: {summary}\n"
                    if method['docstring'] and summary != method['docstring'].splitlines()[0].strip(): # if summary was shortened
                        indented_doc = textwrap.indent(method['docstring'].strip(), "  > ")
                        content += f"{indented_doc}\n\n" # Show full doc if different from summary
                    else:
                        content += "\n" # Just a newline if summary was enough
                content += "\n" # Extra newline after each protocol section
        else:
            content += "This class has no methods defined in the parsed data.\n\n"
        content += "---\n\n"
            
    return content

def generate_se_md(home_page_name, se_concepts_list, input_script_path, parsed_data):
    """Generates content for se.md."""
    content = generate_nav_bar(home_page_name)
    content += f"# Software Engineering Concepts in `{input_script_path}`\n\n"
    content += "This page explores key Software Engineering (SE) concepts, illustrated with examples from the analyzed script.\n\n"

    content += "## Terms to watch for\n"
    if se_concepts_list:
        for term in sorted(se_concepts_list):
            content += f"- {term}\n"
    else:
        content += "- (No specific SE concepts provided for this list)\n"
    content += "\n"

    content += "## Core Concepts Explained\n\n"
    if not se_concepts_list:
        content += "No specific SE concepts were requested for detailed explanation.\n\n"
    else:
        for concept in se_concepts_list:
            content += f"### {concept}\n"
            # Placeholder: LLM would generate detailed explanation and find relevant snippets
            content += f"*(Detailed explanation of '{concept}' as observed in `{input_script_path}` would go here. "
            content += "This includes a general definition, how it's applied in the script, "
            content += "and illustrative code snippets if applicable.)*\n\n"
            # Try to find a relevant snippet (very basic example)
            snippet_found = False
            if "OOP" in concept or "Object-Oriented" in concept:
                if parsed_data and parsed_data["classes"]:
                    first_class = parsed_data["classes"][0]
                    class_def_line = f"class {first_class['name']}:"
                    init_method = next((m for m in first_class['methods'] if m['name'] == '__init__'), None)
                    method_example = ""
                    if init_method:
                         method_example = f"    def __init__(self, {', '.join(init_method['args'][1:])}):\n        # Initialization...\n"
                    elif first_class['methods']:
                         some_method = first_class['methods'][0]
                         method_example = f"    def {some_method['name']}(self, {', '.join(some_method['args'][1:])}):\n        # Method logic...\n"

                    content += f"For example, class definitions are a core part of OOP:\n"
                    content += "```python\n"
                    content += f"{class_def_line}\n"
                    if method_example: content += method_example
                    content += "    pass\n"
                    content += "```\n\n"
                    snippet_found = True
            elif ("File" in concept and "Handling" in concept) or "File I/O" in concept:
                content += "The script might use constructs like `with open(...)` for file operations:\n"
                content += "```python\n"
                content += "try:\n"
                content += f"    with open('example.txt', 'r') as f:\n"
                content += "        content = f.read()\n"
                content += "except FileNotFoundError:\n"
                content += "    print('File not found')\n"
                content += "```\n\n"
                snippet_found = True

            if not snippet_found:
                 content += "_No simple illustrative snippet could be automatically identified for this concept from the script's structure._\n\n"


    content += "## References\n"
    # Placeholder references - LLM should generate more specific ones
    content += "[^1]: Martin, R. C. (2008). *Clean Code: A Handbook of Agile Software Craftsmanship*. Prentice Hall.\n"
    content += "[^2]: Fowler, M. (2018). *Refactoring: Improving the Design of Existing Code* (2nd ed.). Addison-Wesley Professional.\n"
    content += "[^3]: Hunt, A., & Thomas, D. (1999). *The Pragmatic Programmer: From Journeyman to Master*. Addison-Wesley Professional.\n"
    # Placeholder for a Menzies paper if relevant
    content += "[^4]: Menzies, T., & Williams, B. (2008). *Software analytics: So what?* IEEE Software, 25(4), 100-99. (Illustrative)\n\n"
    
    content += "## Review Questions\n"
    if not se_concepts_list:
        content += "1. What are the general benefits of applying SE principles to software development?\n"
        content += "2. How can code readability be improved?\n"
        # ... add more generic questions if no concepts provided
        for i in range(3, 11):
            content += f"{i}. (Generic SE question {i-2})\n"

    else:
        for i, concept in enumerate(se_concepts_list[:5]): # Max 5 questions based on concepts, rest generic
            content += f"{i+1}. Explain the concept of **{concept}** and provide a hypothetical example of its application in `{input_script_path}`.\n"
        if len(se_concepts_list) < 10:
            for i in range(len(se_concepts_list) + 1, 11):
                content += f"{i}. Discuss the importance of [generic SE topic like 'version control' or 'code reviews'] in a software project.\n"
    content += "\n"
    
    return content

def generate_ai_md(home_page_name, ai_concepts_list, input_script_path, parsed_data):
    """Generates content for ai.md."""
    content = generate_nav_bar(home_page_name)
    content += f"# Artificial Intelligence Concepts in `{input_script_path}`\n\n"
    content += "This page discusses key Artificial Intelligence (AI) and Data Science concepts that might be implemented or utilized in the analyzed script.\n\n"

    content += "## Terms to watch for\n"
    if ai_concepts_list:
        for term in sorted(ai_concepts_list):
            content += f"- {term}\n"
    else:
        content += "- (No specific AI concepts provided for this list)\n"
    content += "\n"

    content += "## Core Concepts Explained\n\n"
    if not ai_concepts_list:
        content += "No specific AI concepts were requested for detailed explanation.\n\n"
    else:
        for concept in ai_concepts_list:
            content += f"### {concept}\n"
            content += f"*(Detailed explanation of '{concept}' as potentially observed or applicable to `{input_script_path}` would go here. "
            content += "This includes a general definition, its relevance to data analysis or AI tasks, "
            content += "and illustrative code snippets if applicable from the script.)*\n\n"
            snippet_found = False
            if "Normalization" in concept:
                content += "Data normalization often involves scaling values. A conceptual example:\n"
                content += "```python\n"
                content += "def min_max_normalize(value, data_min, data_max):\n"
                content += "    if data_max == data_min: return 0 # Avoid division by zero\n"
                content += "    return (value - data_min) / (data_max - data_min)\n"
                content += "```\n\n"
                snippet_found = True
            elif "Statistical Measures" in concept or "Metrics" in concept:
                # Check if any method seems to calculate stats
                stat_method = None
                if parsed_data and parsed_data["classes"]:
                    for c in parsed_data["classes"]:
                        for m in c["methods"]:
                            if "stat" in m["name"] or "summary" in m["name"] or "mean" in m["name"] or "std" in m["name"]:
                                stat_method = m
                                break
                        if stat_method: break
                if stat_method:
                    content += f"The script might contain methods like `{stat_method['name']}` for calculating statistics:\n"
                    content += "```python\n"
                    content += f"def {stat_method['name']}(self, {', '.join(stat_method['args'][1:])}):\n"
                    content += f"    # {stat_method['docstring'].splitlines()[0] if stat_method['docstring'] else 'Calculates statistics...'}\n"
                    content += "    pass\n"
                    content += "```\n\n"
                    snippet_found = True
                else:
                    content += "Calculating statistics like mean, median, or standard deviation is common:\n"
                    content += "```python\n"
                    content += "def calculate_mean(numbers):\n"
                    content += "    return sum(numbers) / len(numbers) if numbers else 0\n"
                    content += "```\n\n"
                    snippet_found = True


            if not snippet_found:
                 content += "_No simple illustrative snippet could be automatically identified for this concept from the script's structure._\n\n"

    content += "## References\n"
    content += "[^1]: Russell, S. J., & Norvig, P. (2020). *Artificial Intelligence: A Modern Approach* (4th ed.). Pearson.\n"
    content += "[^2]: Goodfellow, I., Bengio, Y., & Courville, A. (2016). *Deep Learning*. MIT Press.\n"
    content += "[^3]: Bishop, C. M. (2006). *Pattern Recognition and Machine Learning*. Springer.\n"
    # Placeholder for a Menzies paper if relevant
    content += "[^4]: Menzies, T., Kocaguneli, E., Minku, L. L., Peters, F., & Turhan, B. (2013). *Using SE-based Algs for SE*. IEEE Software, 30(6), 71-79. (Illustrative)\n\n"

    content += "## Review Questions\n"
    if not ai_concepts_list:
        content += "1. What is the difference between supervised and unsupervised learning?\n"
        content += "2. Name three common tasks in Natural Language Processing.\n"
        # ... add more generic questions if no concepts provided
        for i in range(3, 11):
            content += f"{i}. (Generic AI question {i-2})\n"
    else:
        for i, concept in enumerate(ai_concepts_list[:5]): # Max 5 questions based on concepts
            content += f"{i+1}. Define **{concept}**. How might it be used in the context of analyzing data with a script like `{input_script_path}`?\n"
        if len(ai_concepts_list) < 10:
            for i in range(len(ai_concepts_list) + 1, 11):
                content += f"{i}. Describe a challenge in [generic AI topic like 'data quality' or 'model interpretability'].\n"
    content += "\n"

    return content

def add_educational_comments(code_string, func_name=""):
    """Adds educational comments to a Python code string."""
    lines = code_string.splitlines()
    commented_lines = []
    
    # General intro comment
    if func_name:
        # Sanitize func_name for concept description
        concept_desc = func_name.replace(ARGS.example_function_prefix, "").replace("_", " ")
        commented_lines.append(f"# This example function, `{func_name}`, demonstrates operations related to {concept_desc}.")
        commented_lines.append(f"# It showcases key steps such as [initialization, data manipulation, output generation, etc. - adapt as needed].")
        commented_lines.append("") # Blank line for separation

    for line_num, line_content in enumerate(lines):
        stripped_line = line_content.strip()
        original_indent = line_content[:len(line_content) - len(line_content.lstrip())]
        comment_to_add = [] # Store multiple comments if needed

        # Skip empty lines or lines that are already just comments
        if not stripped_line or (stripped_line.startswith("#") and not line_content.startswith(original_indent + "# Example:")):
            commented_lines.append(line_content)
            continue
        
        # Add original line first
        commented_lines.append(line_content)

        # Heuristic comments based on line content
        if stripped_line.startswith("def "):
            # Function definition - already covered by intro, or could add specifics about parameters
            # e.g., "Defines the function to accept `param1` (type) and `param2` (type), returning (type)."
            pass
        elif "=" in stripped_line and not re.match(r"[!=<>]=|^\s*(if|elif|while|for|with)", stripped_line): # Assignment
            var_name = stripped_line.split("=")[0].strip()
            value_expr = stripped_line.split("=", 1)[1].strip()
            comment_to_add.append(f"# Assigns the result of evaluating `{value_expr}` to the variable `{var_name}`.")
            if "(" in value_expr and ")" in value_expr: # Likely a function or method call
                func_call_name = value_expr.split("(")[0]
                comment_to_add.append(f"#   The value is obtained by calling `{func_call_name}`.")
                if "." in func_call_name:
                     comment_to_add.append(f"#     This appears to be a method call on an object.")
            elif "[" in value_expr and "]" in value_expr and "for" in value_expr: # List comprehension
                comment_to_add.append(f"#   This uses a list comprehension to construct a list.")

        elif stripped_line.startswith("for ") and " in " in stripped_line and stripped_line.endswith(":"): # For loop
            loop_var = stripped_line.split("for")[1].split("in")[0].strip()
            iterable = stripped_line.split(" in ")[1][:-1].strip()
            comment_to_add.append(f"# Iterates through each item (named `{loop_var}`) in the collection `{iterable}`.")
        
        elif stripped_line.startswith("if ") and stripped_line.endswith(":"): # If statement
            condition = stripped_line.split("if ", 1)[1][:-1].strip()
            comment_to_add.append(f"# Checks if the condition `{condition}` is true.")

        elif stripped_line.startswith("print("):
            # Escape f-string curly braces for the markdown output
            printed_content = stripped_line[6:-1].replace("{", "{{").replace("}", "}}")
            comment_to_add.append(f"# Outputs information to the console: {printed_content}")

        elif stripped_line.startswith("return "):
            return_val = stripped_line.split("return ", 1)[1].strip()
            comment_to_add.append(f"# Returns the value of `{return_val}` from this function.")
        
        # Add collected comments for the current line
        for c_text in comment_to_add:
            commented_lines.append(f"{original_indent}{c_text}")
            
    return "\n".join(commented_lines)


def generate_tutorial_md(parsed_data, home_page_name, example_function_prefix):
    """Generates content for tutorial.md."""
    content = generate_nav_bar(home_page_name)
    content += f"# Tutorials for `{example_function_prefix}` Functions in `{ARGS.input_script_path}`\n\n"
    content += "This section provides tutorials for the example functions found in the analyzed script.\n\n"

    if not parsed_data or not parsed_data["example_functions"]:
        content += f"No functions starting with the prefix `{example_function_prefix}` were found or parsed.\n"
        return content

    # Determine which functions to fully detail (e.g., first 2-3, or specific names)
    # For this example, let's detail all found example functions.
    # In a more complex scenario, one might have a list of "key_examples"
    # or limit the number of fully detailed ones.

    for func_info in parsed_data["example_functions"]:
        func_name = func_info["name"]
        content += f"## Tutorial: `{func_name}`\n\n"

        content += f"### Purpose and Concepts\n"
        purpose = func_info['docstring'].splitlines()[0] if func_info['docstring'] else f"Demonstrates specific functionality related to {func_name.replace(example_function_prefix, '').replace('_', ' ')}."
        content += f"The `{func_name}` function: {purpose}\n"
        content += f"It illustrates concepts such as [TODO: Identify relevant SE/AI concepts, e.g., data processing, configuration usage, algorithm step]. "
        content += f"Refer to general explanations in ([why se](se.md)) and ([ai](ai.md)).\n\n"

        content += f"### Code with comments\n"
        content += "```python\n"
        commented_code = add_educational_comments(func_info['code'], func_name)
        content += commented_code + "\n"
        content += "```\n\n"

        content += f"### Execution and Output Interpretation\n"
        content += f"To run this example, you might call it directly if `{ARGS.input_script_path}` is used as a library, "
        content += f"or it might be triggered via a command-line argument if the script supports it (e.g., `python {ARGS.input_script_path} --run_example {func_name}`).\n"
        content += f"The expected output typically includes [TODO: Describe expected print statements or return values, e.g., 'a summary of processed data', 'confirmation of a setting change', 'the result of a calculation']. "
        content += "Interpreting this output helps verify [TODO: e.g., 'that the data was loaded correctly', 'the algorithm step behaves as intended'].\n\n"
            
        content += f"### Links to `code.md`\n"
        content += f"This example might utilize classes like [TODO: List relevant classes, e.g., `Analyzer` if used] and their methods. "
        content += f"Check `code.md` for details on protocols such as [TODO: List relevant protocols, e.g., `Data Loading & Input`, `Core Logic & Behavior`] used by these components.\n\n"

        content += f"### Exercises\n"
        content += f"1.  **Short Exercise (1-5 mins):** [TODO: e.g., 'Modify a parameter passed to `{func_name}` (if any) or a value within it, and observe the change in output.']\n"
        content += f"2.  **Homework Exercise (1-2 hours):** [TODO: e.g., 'Extend `{func_name}` to also log its main actions to a file named `{func_name}.log`.' or 'Refactor a part of `{func_name}` into a separate helper function and call it.'].\n\n"
        content += "---\n\n"

    return content

def generate_license_md(home_page_name, copyright_year, copyright_holder):
    """Generates content for license.md."""
    content = generate_nav_bar(home_page_name)
    content += "\n# MIT License\n\n"
    content += f"Copyright (c) {copyright_year} {copyright_holder}\n\n"
    content += "Permission is hereby granted, free of charge, to any person obtaining a copy\n"
    content += "of this software and associated documentation files (the \"Software\"), to deal\n"
    content += "in the Software without restriction, including without limitation the rights\n"
    content += "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
    content += "copies of the Software, and to permit persons to whom the Software is\n"
    content += "furnished to do so, subject to the following conditions:\n\n"
    content += "The above copyright notice and this permission notice shall be included in all\n"
    content += "copies or substantial portions of the Software.\n\n"
    content += "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
    content += "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
    content += "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
    content += "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
    content += "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
    content += "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
    content += "SOFTWARE.\n"
    return content

def generate_prompt_txt(params_for_prompt_txt):
    """Generates content for prompt.txt."""
    content = MASTER_PARAMETRIZED_PROMPT_TEMPLATE # This is the raw template string
    content += "\n---\n"
    content += "**Parameters Used for This Website Generation:**\n\n"
    for key, value in params_for_prompt_txt.items():
        # For lists, pretty print them using json.dumps for readability
        if isinstance(value, list):
            val_str = json.dumps(value, indent=4)
        else:
            val_str = str(value)
        content += f"* `{key}`: {val_str}\n"
    content += "---\n"
    return content

# --- Main Execution ---
def main():
    """
    Main function to parse arguments, analyze the input script,
    and generate all website files.
    """
    global ARGS # Allow ARGS to be used by generator functions

    parser = argparse.ArgumentParser(description=f"Generates an educational website from a Python script. (Generated by {__file__})")
    parser.add_argument("input_script_path", help="Path to the Python script to analyze.")
    parser.add_argument("--example_function_prefix", default="example_", help="Prefix for example functions to document (default: 'example_').")
    parser.add_argument("--se_concepts_list", nargs='*', default=["Pythonic Code", "Object-Oriented Programming", "CLI Design", "File I/O", "Modularity and Namespaces", "Unit Testing", "Exception Handling"], help="List of SE concepts to cover.")
    parser.add_argument("--ai_concepts_list", nargs='*', default=["Core Data Structures (Lists, Dictionaries)", "Algorithmic Complexity Basics", "Heuristic Methods", "State Space Search (Conceptual)", "Data Preprocessing (Normalization)", "Evaluation Metrics"], help="List of AI concepts to cover.")
    parser.add_argument("--copyright_year", default="2025", help="Copyright year for license (default: '2025').")
    parser.add_argument("--copyright_holder", default="Your Name or Organization <email@example.com>", help="Copyright holder for license (default: 'Your Name or Organization <email@example.com>').")
    parser.add_argument("--output_python_script_name", default=os.path.basename(__file__), help="Name of this generator script (for prompt.txt).")
    parser.add_argument("--output_dir", default="docs/", help="Directory to save generated website files (default: 'docs/').")
    parser.add_argument("--home_page_name", default="Home.md", help="Name of the main landing page (default: 'Home.md').")
    
    ARGS = parser.parse_args()

    # Create output directory if it doesn't exist
    os.makedirs(ARGS.output_dir, exist_ok=True)
    print(f"Output directory: {os.path.abspath(ARGS.output_dir)}")

    # Parse the input Python script
    print(f"Parsing input script: {ARGS.input_script_path}...")
    parsed_script_data = parse_input_script(ARGS.input_script_path, ARGS.example_function_prefix)
    if parsed_script_data is None:
        print("Failed to parse input script. Exiting.")
        return

    # --- Collect parameters for prompt.txt ---
    # Convert lists to their string representations for storage if needed, or use json
    params_for_prompt = {
        'INPUT_SCRIPT_PATH': ARGS.input_script_path,
        'EXAMPLE_FUNCTION_PREFIX': ARGS.example_function_prefix,
        'SE_CONCEPTS_LIST': ARGS.se_concepts_list, # Keep as list, json.dumps will handle
        'AI_CONCEPTS_LIST': ARGS.ai_concepts_list, # Keep as list
        'COPYRIGHT_YEAR': ARGS.copyright_year,
        'COPYRIGHT_HOLDER': ARGS.copyright_holder,
        'OUTPUT_PYTHON_SCRIPT_NAME': ARGS.output_python_script_name,
        'OUTPUT_DIR': ARGS.output_dir,
        'HOME_PAGE_NAME': ARGS.home_page_name
    }

    # --- Generate Files ---
    files_to_generate = {
        ARGS.home_page_name: lambda: generate_home_md(ARGS.home_page_name, ARGS.output_python_script_name),
        "Install.md": lambda: generate_install_md(ARGS.home_page_name),
        "code.md": lambda: generate_code_md(parsed_script_data, ARGS.home_page_name),
        "se.md": lambda: generate_se_md(ARGS.home_page_name, ARGS.se_concepts_list, ARGS.input_script_path, parsed_script_data),
        "ai.md": lambda: generate_ai_md(ARGS.home_page_name, ARGS.ai_concepts_list, ARGS.input_script_path, parsed_script_data),
        "tutorial.md": lambda: generate_tutorial_md(parsed_script_data, ARGS.home_page_name, ARGS.example_function_prefix),
        "license.md": lambda: generate_license_md(ARGS.home_page_name, ARGS.copyright_year, ARGS.copyright_holder),
        "prompt.txt": lambda: generate_prompt_txt(params_for_prompt)
    }

    for filename, generator_func in files_to_generate.items():
        filepath = os.path.join(ARGS.output_dir, filename)
        try:
            print(f"Generating {filepath}...")
            content = generator_func()
            with open(filepath, "w", encoding="utf-8") as f:
                f.write(content)
            print(f"Successfully generated {filepath}")
        except Exception as e:
            print(f"Error generating {filepath}: {e}")
            import traceback
            traceback.print_exc()


    print(f"\nWebsite generation complete. Files are in '{os.path.abspath(ARGS.output_dir)}'.")

if __name__ == "__main__":
    main()

