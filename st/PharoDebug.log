THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #print
20 August 2023 11:14:47.87429 pm

VM: Mac OS - arm64 - 1000 - CoInterpreter VMMaker-tonel.1 uuid: 5225a81b-6fbf-0d00-86f3-f7200df24b96 Aug 16 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 5225a81b-6fbf-0d00-86f3-f7200df24b96 Aug 16 2023
v10.0.6 - Commit: b67609b9 - Date: 2023-08-16 18:51:13 +0200

Image: Pharo11.0.0 [Build information: Pharo-11.0.0+build.704.sha.7e0219e7f720faf2cfd6083adef507741de47cf2 (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #print
	Receiver: 1
	Arguments and temporary variables: 
		aMessage: 	print
		exception: 	Instance of SmallInteger did not understand #print
		resumeValue: 	nil
	Receiver's instance variables: 
1

[:x| x print] in UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		x: 	1
	Receiver's instance variables: 
nil

Array(SequenceableCollection)>>do:
	Receiver: #(1 2 3)
	Arguments and temporary variables: 
		aBlock: 	[:x| x print]
		index: 	1
	Receiver's instance variables: 
#(1 2 3)

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
	Receiver: an OCReceiverDoItSemanticScope
	Arguments and temporary variables: 
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		outerScope: 	nil
		targetReceiver: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		doItMethod: 	UndefinedObject>>#DoIt
	Receiver's instance variables: 
		ast: 	DoIt

	^ #( 1 2 3 ) do: [ :x | x print ]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


OpalCompiler>>evaluate:
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		textOrString: 	'#(1 2 3)  do: [:x| x print]'
	Receiver's instance variables: 
		ast: 	DoIt

	^ #( 1 2 3 ) do: [ :x | x print ]
		source: 	a ReadStream
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aStream: 	'#(1 2 3)  do: [:x| x print]'
		result: 	nil
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [..]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :error | self handleError: error ]
	Receiver's instance variables: 
		outerContext: 	EvaluateCommandLineHandler>>evaluate:
		compiledBlock: 	a CompiledBlock: [
	result := Smalltalk compiler evaluate: a[..]
		numArgs: 	0
		receiver: 	an EvaluateCommandLineHandler


EvaluateCommandLineHandler>>evaluate:
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		result: 	nil
		aStream: 	'#(1 2 3)  do: [:x| x print]'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>evaluateArguments
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
		argumentString: 	'#(1 2 3)  do: [:x| x print]'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler>>activate
	Receiver: an EvaluateCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver
		sourceFiles: 	nil


EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: EvaluateCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArguments
	Receiver's instance variables: 
		superclass: 	STCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->EvaluateCommandLineHandler>>#acti[..]
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		commentSourcePointer: 	nil
		subclasses: 	nil
		name: 	#EvaluateCommandLineHandler
		classPool: 	nil
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'CodeImportCommandLineHandlers-Base'


[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ aCommandLinehandler activateWith: commandLine ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit |
		^ self handleExit: exit for: aCommandLinehandler ]
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activateSub[..]
		compiledBlock: 	a CompiledBlock: [ aCommandLinehandler activateWith: command[..]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLinehandler: 	EvaluateCommandLineHandler
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		handlers: 	an OrderedCollection(EvaluateCommandLineHandler)
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		aString: 	'eval'
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit |
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ self handleArgument: self firstArgument ]
	Arguments and temporary variables: 
		exception: 	Exit
		handlerAction: 	[ :exit |
			"If the command line is protected by password, [..]
	Receiver's instance variables: 
		outerContext: 	[ [ self handleArgument: self firstArgument ]
		on: Exit
		do[..]
		compiledBlock: 	a CompiledBlock: [ self handleArgument: self firstArgument ]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler


[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit |
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit |
			"If the co[..]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler(BasicCommandLineHandler)>>activate
		compiledBlock: 	a CompiledBlock: [ [ self handleArgument: self firstArgument[..]
		numArgs: 	0
		receiver: 	a PharoCommandLineHandler



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #print
[:x| x print] in UndefinedObject>>DoIt
Array(SequenceableCollection)>>do:
UndefinedObject>>DoIt
OCReceiverDoItSemanticScope(OCDoItSemanticScope)>>evaluateDoIt:
OpalCompiler>>evaluate
OpalCompiler>>evaluate:
[
	result := Smalltalk compiler evaluate: aStream.
	self hasSessionChanged
		ifFalse: [
			self stdout
				print: result;
				lf ] ] in EvaluateCommandLineHandler>>evaluate:
FullBlockClosure(BlockClosure)>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
FullBlockClosure(BlockClosure)>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self handleArgument: self firstArgument ] in [ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit |
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
FullBlockClosure(BlockClosure)>>on:do:
[ [ self handleArgument: self firstArgument ]
		on: Exit
		do: [ :exit |
			"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
			self class commandLinePasswordManager hasPasswordSet
				ifTrue: [ Smalltalk snapshot: false andQuit: true ].
			self handleExit: exit ] ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in AtomicSharedQueue>>waitForNewItems
  stack:

AtomicSharedQueue>>waitForNewItems
AtomicSharedQueue>>next
TKTWorkerProcess>>privateNextTask
TKTWorkerProcess>>workerLoop
MessageSend>>value
[ aValuable value ] in TKTPharoProcessProvider>>createProcessDoing:named:
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>endProcess
  stack:

Process>>endProcess
------------------------------

Process: a Process in Process>>endProcess
  stack:

Process>>endProcess
------------------------------

Process: a Process in Process>>endProcess
  stack:

Process>>endProcess
------------------------------

Process: a Process in Process>>endProcess
  stack:

Process>>endProcess
------------------------------

Process: a Process in DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
  stack:

DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
[  [runTimerEventLoop] whileTrue:
		[	|nowTick|
			"Warning! Stepping <Over> the following line may lock the Image. Use <Into> or <Proceed>."
		 	ticker waitForUserSignalled: timingSemaphore orExpired: activeDelay.

			"Invoke the api back-ends, which set the transfer-variable to nil"
			suspendSemaphore ifNotNil: [ self suspendAtTimingPriority    ].
			delayToStart     ifNotNil: [ self scheduleAtTimingPriority   ].
			delayToStop      ifNotNil: [ self unscheduleAtTimingPriority ].

			"Signal any expired delays"
			nowTick := ticker nowTick.
			[ 	activeDelay notNil and: [nowTick >= activeDelay resumptionTick] ]
					whileTrue: [
						activeDelay timingPrioritySignalExpired.
						activeDelay := suspendedDelays removeFirstOrNil ].
		]
	] in DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
FullBlockClosure(BlockClosure)>>ensure:
DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
[ self runBackendLoopAtTimingPriority ] in DelaySemaphoreScheduler(DelayBasicScheduler)>>startTimerEventLoopPriority:
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in MorphicRenderLoop>>doOneCycleWhile:
  stack:

MorphicRenderLoop>>doOneCycleWhile:
[ MorphicRenderLoop new doOneCycleWhile: [ true ] ] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>endProcess
  stack:

Process>>endProcess
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in [self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
  stack:

[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[self finalizationProcess] in WeakArray class>>restartFinalizationProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in Process>>endProcess
  stack:

Process>>endProcess
------------------------------

Process: a Process in Process>>endProcess
  stack:

Process>>endProcess
------------------------------

Process: a Process in Process>>endProcess
  stack:

Process>>endProcess
------------------------------

Process: a Process in [
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
  stack:

[
		[ true ] whileTrue: [
			semaphore wait.
			[self executeCallback: self nextPendingCallback]
				on: Exception fork:  [:ex | ex pass ] ] ] in TFCallbackQueue>>forkCallbackProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
------------------------------

Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[:logger |
		logger nextPutAll: 'Processes and their stacks: ';cr.

		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.

			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.
		]] in [ Smalltalk
		logError: aString
		inContext: aContext.

	" Print stacks of all current processes "

	Smalltalk logDuring: [:logger |
		logger nextPutAll: 'Processes and their stacks: ';cr.

		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.

			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.
		]].
	] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[
		logStream := self openLog.
		aMonadicBlock value: logStream.
	] in SmalltalkImage>>logDuring:
FullBlockClosure(BlockClosure)>>ensure:
SmalltalkImage>>logDuring:
[ Smalltalk
		logError: aString
		inContext: aContext.

	" Print stacks of all current processes "

	Smalltalk logDuring: [:logger |
		logger nextPutAll: 'Processes and their stacks: ';cr.

		Process allInstances do: [:each | | ctx |
			logger nextPutAll: 'Process: '; print: each; cr; nextPutAll: '  stack:'; cr; cr.

			ctx := each isActiveProcess ifTrue: [ thisContext sender ] ifFalse: [ each suspendedContext ].
			ctx ifNotNil: [
				(ctx stackOfSize: 20) do: [:s | logger print: s; cr ]].
			logger nextPutAll: '------------------------------'; cr; cr.
		]].
	] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
FullBlockClosure(BlockClosure)>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
MessageNotUnderstood(Exception)>>unhandledErrorAction
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
MessageNotUnderstood(Exception)>>raiseUnhandledError
MessageNotUnderstood(Exception)>>defaultAction
MessageNotUnderstood>>defaultAction
------------------------------

