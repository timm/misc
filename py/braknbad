#!/usr/bin/env python3 -B
# vim: ft=python:nospell:sta:et:sw=2:ts=2:sts=2
""" 

## Breaking bad

"I am the one who knocks."

      .-------.
      |       |
    -=_________=-
      ___   ___
     |___)=(___|
    
         ###
        # = #
        #####
         ###

- Divide data into regions of bad and better.
- Find the least you need to do to nudge things away from bad.

     Better
    .------.
    |    36| <--- a score you want to minimize
    | Br   |
    .______.______.
           |    56| <--- a larger, hence worse, score
           | Ba   |
           .______.
             Bad

"""

def config(): 
  """Set global options.i to change these, at the comamnd-line,
   type
       
        ./braknbad GROUP -OPTION value

  where GROUP is one of char,dist,do,etc and OPTION
  is some sub-setting in GROUP; e.g. 

        ./braknbad dist -p 3

  """ 
  return o(
   char = o( no    = "?",
             less  = "<",  
             more  = ">",
             sep   = ",", 
             doomed= r'([\n\t\r ]|#.*)'),
   dist = o( p=2 ),
   do   = o(  run=r"."     ),
   nb   = o(  k=1, m=2     ),
   row  = o(  doms = 64    ),
   two  = o(  better = 0.2 )
   )


#--------- --------- --------- --------- -------- ----------
import re,sys,traceback,random

class o:
  def __init__(i,**d) : i.__dict__.update(**d)
  def __repr__(i):
    lst= [(k, v) for k,v in i.__dict__.items() if k[0] != "_"]
    return i.__class__.__name__ + '{' + ", ".join(
           [('%s=%s' % (k, v)) for k,v in sorted(lst)]) +'}'

any = random.choice

def atom(x):
  "coerce x into the right kind of atom"
  try: return int(x)
  except:
    try: return float(x)
    except: return x


def cli(d,args=sys.argv[1:]):
  "Allow command lines args to update fields in the THE object" 
  args   = [atom(x) for x in args]
  what   = {}
  groups = d.__dict__
  while args:
    arg = args.pop(0)
    if arg in groups:
      what = groups[arg].__dict__
    else:
      assert isinstance(arg,str) and arg[0] == "-", "bad flag '%s'" %arg
      arg = arg[1:]
      assert arg in what, "%s not one of %s" % (arg,list(what.keys()))
      old = what[arg]
      if isinstance(old, bool):
        what[arg] = not what[arg]
      else:
        val = args.pop(0)
        assert type(old)==type(val), "'%s' value not of type '%s'"%(
                                       arg,type(old))
        what[arg] = val
  return d   

THE=config()

class Eg(o):
  all = []
  y   = 0
  n   = 0
  tell= "#Tests 0 tries 0 fails 100% passes."
  def run(): 
    [Eg.run1(one) for one in Eg.all]
  def run1(f):
    if re.match(THE.do.run, f.__name__):
      print("\n-----| %s |%s" % (f.__name__,"-"*40))
      if f.__doc__:
        print("# "+ re.sub(r'\n[ \t]*',"\n# ", f.__doc__))
      Eg.y += 1
      try:    
        f()
      except: 
        Eg.n += 1
        y,n  = Eg.y, Eg.n
        print(traceback.format_exc())
        Eg.tell = "#Tests %s tries %s fails %s%% passed." % (
                    y,n, round(100*(y/(y+n+0.0001)),0))

def eg(f): Eg.all += [f]; return f

class Row(o):
  "Holder for lists of values."
  def __init__(i,lst):
    i.cells=lst
    i.ranges=[None]*len(lst)
    i.count=0
  def dom(i,j,t):
    n = len(t.cols.objs)
    s1 = s2 = 0
    for c in t.cols.objs:
      x,y = i.cells[c.pos], j.cells[c.pos]
      x,y = c.norm(x), c.norm(y)
      s1 -= 10**( c.w * (x-y)/n )
      s2 -= 10**( c.w * (y-x)/n )
    return s1/n < s2/n

class Tbl(o):
  def __init__(i,names=[], rows=None):
    i.rows = []
    i.cols = o(all=[], decs = [], objs=[])
    if names: 
      i.header(names)
      i.names = names
    if rows:  
      i.read(rows)
      i.names = [ c.txt for c in i.cols.all ]
  def centroid(i):
    return [ c.centroid() for c in i.cols.all ]
  def div(i):
    n = THE.row.doms
    for r1 in i.rows:
      if n < len(i.rows):
        tmp= sum(r1.dom(any(i.rows),i) for _ in range(n)) 
      else: 
        tmp= sum(r1.dom(r2,i) for r2 in i.rows)
      r1.count = tmp/n
    return Two(i, i.rows)
  def clone(i):
    return Tbl(i.names)
  def header(i,names):
    for n,s in enumerate(names):
      w     = -1 if s[0] == '<' else 1
      x     = (Num    if s[0] in "<>$" else Sym)(s,n,w)
      what  = i.cols.objs if s[0] in '<>' else i.cols.decs
      what += [x]
      i.cols.all += [x]
      print(x)
  def read(i,rows):
    for row in rows:
      i + row if i.cols.all else i.header(row)
  def __add__(i,lst):
    lst     = [ c + lst[c.pos] for c in i.cols.all ]
    i.rows += [ Row(lst) ]
  def like(i,lst,ns):
    n    = len(i.rows)
    k, m = THE.nb.k, THE.nb.m
    like = prior = (n + k) / (ns + k*2)
    for c in i.all.decs:
      x     = lst[c.pos]
      if x == THE.char.no: continue
      f     = c.bag.get(x,0)
      inc   = (f + m*prior) / (n + m)
      like *= inc
    return like
 
class Num(o):
  def __init__(i,txt="",pos=0,w=1):
    i.txt,i.pos = txt,pos
    i.w=w
    i.n,i.mu,i.m2 = 0,0,0
    i.lo,i.hi     = 10**32, -10**32
  def centroid(i): return i.mu
  def norm(i,x): 
    return (x - i.lo) / (i.hi - i.lo + 10**-32)
  def __add__(i,x):
    if x == THE.char.no: return x
    x = float(x)
    if x < i.lo: i.lo = x
    if x > i.hi: i.hi = x
    i.n  += 1
    d     = x - i.mu
    i.mu += d/i.n
    i.m2 += d*(x - i.mu)
    i.sd  = i.sd0()
    return x
  def sd0(i):
    if i.m2 < 0: return 0
    if i.n  < 2: return 0
    return (i.m2/(i.n - 1 + 10**-32))**0.5

class Sym(o):
  def __init__(i,txt="",pos=0,w=1):
    i.txt,i.pos = txt,pos
    i.w=w
    i.n,i.most,i.mode,i.bag = 0,0,None,{}
  def centroid(i): return i.mode
  def __add__(i,x):
    if x == THE.char.no: return x
    i.n += 1
    c = i.bag[x] = i.bag.get(x,0) + 1
    if c > i.most:
       i.most, i.mode = c, x
    return x

class Two:
  """Stores two tables: one for `_bad` things
     and one for `_better` things."""
  def __init__(i,t, lst):
    i._bad, i._better = t.clone(), t.clone()
    lst = sorted(lst, key=lambda z:z.count)
    n   = int(len(lst)*THE.two.better)
    for m,one in enumerate(lst):
      a = one.cells
      (i._bad + a) if m < n else (i._better + a)
  def bad(i,lst)     : i._bad + lst
  def better(i,lst)  : i._better + lst
  def p(i,lst): 
    ns = len(i._bad.rows) + len(i._better.rows)
    l1 = i._bad.like(   i,lst, ns)
    l2 = i._better.like(i,lst, ns)
    return l1/(l1+l2), l2/(l1+l2)
   
class Range(o):
  id = 0
  def __init__(i,lo,hi) : 
    i.lo,i.hi=lo,hi
    i.id = Range.id = Range.id + 1
  def __hash__(i):
    return i.id

def csv(file):
  use, txt = [], ""
  with open(file) as fs:
    for line in fs:
      txt += re.sub(THE.char.doomed, '', line)
      if txt and txt[-1] != THE.char.sep:
        lst = txt.split(THE.char.sep) 
        if lst:
          txt = ""
          use = use or [n for n,s in enumerate(lst) 
                       if s[0] != THE.char.no ]
          if len(lst) != len(use):
            err("wanted %s cells, got %s in %s", 
                (len(use), len(lst),lst))
          yield [lst[n] for n in use]

@eg
def doco():
  import subprocess
  subprocess.call(["/usr/bin/pydoc","./braknbad"])

if __name__ == "__main__":
  THE = cli(THE)
  #Eg.run()
  t =  Tbl(rows = csv("../data/auto93.csv")).div()
  print(t._bad.centroid())
  print(t._better.centroid())
