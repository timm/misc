<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>simp API documentation</title>
<meta name="description" content="Name:
simp.py â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>simp</code></h1>
</header>
<section id="section-intro">
<h2 id="name">Name</h2>
<p>simp.py</p>
<h2 id="version">Version</h2>
<p>0.2</p>
<h2 id="usage">Usage</h2>
<p>simp.py [options]</p>
<h2 id="options">Options</h2>
<p>-h
Help.<br>
-v
Verbose. <br>
-s=n
Set random number seed [default: 1].<br>
-k=n
Speed in knots [default: 10].
</p>
<h2 id="examples">Examples</h2>
<ul>
<li>Installation: <code>sh INSTALL.md</code></li>
<li>optionally, install command line IDE tools
</li>
<li>Unittests: <code>python3 tests.py</code></li>
<li>Continual tests: <code>rerun 'python3 tests.py'</code></li>
<li>Documentation: <code>sh DOCS.md</code></li>
</ul>
<h2 id="notes">Notes</h2>
<p>Simplest to tricky-est, this code divides
into <code>LIB</code>,<code>BINS</code>,<code>TABLE</code>.</p>
<ul>
<li><code>LIB</code> contains misc
utilities.</li>
<li><code>TABLE</code> manages sets of rows.</li>
<li><code>BINS</code> does discretization.</li>
</ul>
<h2 id="author">Author</h2>
<p>Tim Menzies
timm@ieee.org
<a href="http://menzies.us">http://menzies.us</a></p>
<h2 id="copyright">Copyright</h2>
<p>(c) 2020 Tim Menzies, MIT license,
<a href="https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
&#34;&#34;&#34;
Name:
    simp.py

Version:
    0.2

Usage:
    simp.py [options]

Options:

    -h        Help.  
    -v        Verbose.   
    -s=n      Set random number seed [default: 1].  
    -k=n      Speed in knots [default: 10].   

Examples:

    - Installation: `sh INSTALL.md`
       - optionally, install command line IDE tools   
    - Unittests: `python3 tests.py`
    - Continual tests: `rerun &#39;python3 tests.py&#39;`
    - Documentation: `sh DOCS.md`

Notes:
    Simplest to tricky-est, this code divides 
    into `LIB`,`BINS`,`TABLE`.

    - `LIB` contains misc  utilities.
    - `TABLE` manages sets of rows.
    - `BINS` does discretization.

Author:
   Tim Menzies
   timm@ieee.org
   http://menzies.us

Copyright:
   (c) 2020 Tim Menzies, MIT license,
   https://opensource.org/licenses/MIT

&#34;&#34;&#34;

import re
import sys
import math
import copy
import bisect
from docopt import docopt
from random import random, seed, choice
from random import shuffle as rshuffle


def opt(d, **tyoes):
  &#34;&#34;&#34;LIB: coerce dictionaries into simple keys
  whose values are of known `types`.&#34;&#34;&#34;
  d = {re.sub(r&#34;^[-]+&#34;, &#34;&#34;, k): v for k, v in d.items()}
  for k, f in types.items():
    d[k] = f(d[k])
  return o(**d)


def same(x):
  &#34;LIB: Return `x`, unaltered.&#34;
  return x


def first(a):
  &#34;LIB: Return first item in `a`.&#34;
  return a[0]


def last(a):
  &#34;LIB: Return last item in `a`.&#34;
  return a[-1]


def shuffle(a):
  &#34;LIB: return a randomly shuffled list.&#34;
  rshuffle(a)
  return a


class o:
  &#34;&#34;&#34;LIB: Class that can pretty print; that
  can `inc`rement and `__add__` their values.&#34;&#34;&#34;
  def __init__(i, **d):
    &#34;New item.&#34;
    i.d.update(**d)

  @property
  def d(i):
    &#34;Return the internal dictionary.&#34;
    return i.__dict__

  def __repr__(i):
    &#34;Pretty print. Hide private keys (those starting in `_`)&#34;
    n = i.__class__.__name__
    return n + &#34;{&#34; + &#39;, &#39;.join(
        [(&#39;:%s %s&#39; % (k, i.d[k])) for k in sorted(i.d.keys())
            if str(k)[0] != &#34;_&#34;]) + &#34;}&#34;

  def inc(i, x):
    &#34;Increment `x` (starting at zero)&#34;
    i.d[x] = i.d.get(x, 0) + 1

  def __add__(i, j):
    &#34;Add together the numeric values in `i` and `j`.&#34;
    k = o()
    for x, v in i.d.items():
      k[x] = v
    for x, v in j.d.items():
      k.d[x] = v + k.d.get(x, 0)
    return k


class Row(o):
  &#34;&#34;&#34;
  TABLE: holds one example from a table `_tab`
  in &#39;cells&#39; (and, if the row has been descretized,
  in &#39;bins&#39;).
  &#34;&#34;&#34;
  def __init__(i, tab, cells):
    i._tab = tab
    i.cells = cells
    i.bins = cells[:]
    i.seen = False
    i.dom = 0

  def __getitem__(i, k):
    return i.cells[k]

  def better(i, j):
    c = i._tab.cols
    s1, s2, n = 0, 0, len(c.y) + 0.0001
    for k in c.y:
      x = i.bins[k]
      y = j.bins[k]
      s1 -= math.e**(c.w[k] * (x - y) / n)
      s2 -= math.e**(c.w[k] * (y - x) / n)
    return s1 / n &lt; s2 / n

  def dist(i, j, what=&#34;x&#34;):
    d, n = 0, 0
    for c in i._tab.cols[what]:
      a, b = i.cells[c], j.cells[c]
      n += 1
      if a == &#34;?&#34; and b == &#34;?&#34;:
        d = 1
      else:
        if a == &#34;?&#34;:
          a = 0 if b &gt; 0.5 else 1
        if b == &#34;?&#34;:
          b = 0 if a &gt; 0.5 else 1
      d += abs(a - b) ^ 2
    return (d / (n + 0.001))**0.5

  def status(i):
    return [i[y] for y in i._tab.cols.y]


class Tab(o):
  &#34;&#34;&#34;
  TABLE:  holds many examples in `rows`.  Also, `cols` stores
  type descriptions for each column (and `cols` is built from the
  names in the first row).
  &#34;&#34;&#34;
  def __init__(i, src=[]):
    &#34;&#34;&#34;
    Create from `src`, which could be a list,
    a `.csv` file name, or a string.
    &#34;&#34;&#34;
    i.rows = []
    i.cols = o(all={}, w={}, klass=None, x={}, y={}, syms={}, nums={})
    i._bins = {}
    [i.add(row) for row in cols(rows(src))]

  def add(i, row):
    &#34;The first `row` goes to the header. All the rest got to `rows`.&#34;
    i.row(row) if i.cols.all else i.header(row)

  ch = o(klass=&#34;!&#34;, num=&#34;$&#34;,
         less=&#34;&lt;&#34;, more=&#34;&gt;&#34;, skip=&#34;?&#34;,
         nums=&#34;&gt;&lt;$&#34;, goal=&#34;&lt;&gt;!,&#34;)

  def header(i, lst):
    &#34;&#34;&#34;
    Using the magic characters from `Tab.ch`, divide the columns
    into the symbols, the numbers, the x cols, the y cols, the
    klass col. Also, store them all in the `all` list.
    &#34;&#34;&#34;
    c, ch = i.cols, Tab.ch
    c.klass = -1
    for pos, txt in enumerate(lst):
      c.all[pos] = txt
      (c.nums if txt[0] in ch.nums else c.syms)[pos] = txt
      (c.y if txt[0] in ch.goal else c.x)[pos] = txt
      c.w[pos] = -1 if ch.less in txt else 1
      if ch.klass in txt:
        c.klass = pos

  def row(i, lst):
    i.rows += [Row(i, lst)]

  def bins(i, goal=None, cohen=.2):
    &#34;&#34;&#34;
    Divide numerics into  ranges that best select for `goal`.  If
    `goal=None` then just divide into sqrt(N) bins, that differ
    by more than a small amount (at least `.2*sd`).
    &#34;&#34;&#34;
    def appy(runs, x):
      if x == &#34;?&#34;:
        return x
      n = len(runs)
      for pos, run in enumerate(runs):
        # print(x, run.xlo)
        if x &lt; run.xlo:
          break
        if run.xlo &lt;= x &lt; run.xhi:
          break
      return round((pos + 1) / n, 2)
    # ----------------
    for x in i.cols.nums:
      # find the bins
      i._bins[x] = bins = numbins(
          i.rows, want=want, x=x, goal=goal, cohen=cohen,
          y=i.cols.klass)
      # apply the bins
      for row in i.rows:
        row.bins[x] = appy(bins, row[x])


def symbins(lst, x=0, y=-1, want=None, *_):
  &#34;BINS: return ranges for columns of symbols.&#34;
  def run1(z=&#34;__all__&#34;):
    return o(xlo=z, xhi=z, x=x, ys=o(), val=0)
  all = run1()
  bins = {}
  for z in lst:
    xx, yy = z[x], z[y]
    if xx != &#34;?&#34;:
      if xx not in bins:
        bins[xx] = run1(xx)
      one = bins[xx]
      klass = 1 if yy == want else 0
      one.ys.inc(klass)
      all.ys.inc(klass)
  return [score(one, all) for one in bins.values()]


def score(z, all, e=0.00001):
  &#34;&#34;&#34;
  Score a bin by prob*support that it selects for the goal.
  If too small, set to zero.
  &#34;&#34;&#34;
  yes = z.ys.d.get(1, 0) / (all.ys.d.get(1, 0) + e)
  no = z.ys.d.get(0, 0) / (all.ys.d.get(0, 0) + e)
  tmp = yes**2 / (yes + no + e)
  z.val = tmp if tmp &gt; 0.01 else 0
  return z


def numbins(lst, x=0, y=-1, want=None,
            cohen=.2, enough=.2, trivial=.05):
  &#34;BINS: return ranges for columns of numbers.&#34;
  def run1(z=&#34;__all__&#34;):
    &#34;Splits have these slots.&#34;
    return o(xlo=z, xhi=z, x=x, ys=o(), val=0)

  def split(xlo=0, runs=[run1(0)]):
    &#34;Split a long list into a few bins.&#34;
    n = len(lst)**enough
    while n &lt; 10 and n &lt; len(lst) / 2:
      n *= 1.2
    for xhi, z in enumerate(lst):
      if xhi - xlo &gt;= n:  # split when big enough
        if len(lst) - xhi &gt;= n:  # split when enough remains after
          if z[x] != lst[xhi - 1][x]:  # split when values differ
            runs += [run1(xhi)]
            xlo = xhi
      now = runs[-1]
      now.xhi = xhi + 1
      all.xhi = xhi + 1
      klass = 1 if z[y] == want else 0
      now.ys.inc(klass)
      all.ys.inc(klass)
    return [score(run) for run in runs]

  def merge(runs, j=0, tmp=[]):
    &#34;&#34;&#34;Merge things that are too small to be difference
    or, if we know the goal we want,  if the splits
    aren&#39;t good ways to get to the goal.&#34;&#34;&#34;
    def add(z1, z2):
      return score(o(xlo=z1.xlo, xhi=z2.xhi, x=x,
                     ys=z1.ys + z2.ys, val=0))

    def per(z=0.5):
      return lst[int(len(lst) * z)][x]
    # --------------------------------------
    d = cohen * (per(.9) - per(.1)) / 2.54  # cohen*sd
    while j &lt; len(runs):
      a = runs[j]
      if j &lt; len(runs) - 1:
        b = runs[j + 1]
        ab = add(a, b)
        # split if the difference is too small or splits dont do better for `want`.
        if(per(b) - per(a)) &lt; d or want and ab.val &gt;= a.val and ab.val &gt;= b.val:
          a = ab
          j += 1
      tmp += [a]
      j += 1
    return tmp if len(tmp) == len(runs) else merge(tmp, 0, [])

  def cleanup(z):
    &#34;Final clean up. Replace indexes with values at those indexes.&#34;
    def n(n0): return lst[min(len(lst) - 1, n0)][x]
    z.xlo, z.xhi = n(z.xlo), n(z.xhi)
    return z

  # --------------------------------------------------------------
  lst = sorted((z for z in lst if z[x] != &#34;?&#34;), key=lambda z: z[x])
  all = run1(0)
  return [xplain(run) for run in merge(split())]


def smo(tab, n1=10):
  lst = shuffle(tab.rows)
  for i, j in pairs(lst[:n1]):
    i.dom += i.better(j)


def pairs(lst):
  j = 0
  while j &lt; len(lst) - 1:
    yield lst[j], lst[j + 1]
    j += 2


def rows(x=None, f=sys.stdin):
  &#34;Read from stdio or file or string or list. Kill whitespace or comments.&#34;
  def items(z):
    for y in z:
      yield y

  def strings(z):
    for y in z.splitlines():
      yield y

  def csv(z):
    with open(z) as fp:
      for y in fp:
        yield y

  if x:
    if isinstance(x, (list, tuple)):
      f = items
    elif x[-3:] == &#39;csv&#39;:
      f = csv
    else:
      f = strings
  for y in f(x):
    if isinstance(y, str):
      y = re.sub(r&#39;([\n\t\r ]|#.*)&#39;, &#39;&#39;, y).strip()
      if y:
        yield y.split()
    else:
      yield y


def cols(src):
  &#34;Ignore columns if, on line one, the name contains &#39;?&#39;.&#34;
  todo = None
  for a in src:
    todo = todo or [n for n, s in enumerate(a) if &#34;?&#34; not in s]
    yield [a[n] for n in todo]


if __name__ == &#39;__main__&#39;:
  my = opt(docopt(__doc__), s=int, k=int)
  seed(my.s)
  print(my)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="simp.cols"><code class="name flex">
<span>def <span class="ident">cols</span></span>(<span>src)</span>
</code></dt>
<dd>
<div class="desc"><p>Ignore columns if, on line one, the name contains '?'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cols(src):
  &#34;Ignore columns if, on line one, the name contains &#39;?&#39;.&#34;
  todo = None
  for a in src:
    todo = todo or [n for n, s in enumerate(a) if &#34;?&#34; not in s]
    yield [a[n] for n in todo]</code></pre>
</details>
</dd>
<dt id="simp.first"><code class="name flex">
<span>def <span class="ident">first</span></span>(<span>a)</span>
</code></dt>
<dd>
<div class="desc"><p>LIB: Return first item in <code>a</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first(a):
  &#34;LIB: Return first item in `a`.&#34;
  return a[0]</code></pre>
</details>
</dd>
<dt id="simp.last"><code class="name flex">
<span>def <span class="ident">last</span></span>(<span>a)</span>
</code></dt>
<dd>
<div class="desc"><p>LIB: Return last item in <code>a</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last(a):
  &#34;LIB: Return last item in `a`.&#34;
  return a[-1]</code></pre>
</details>
</dd>
<dt id="simp.numbins"><code class="name flex">
<span>def <span class="ident">numbins</span></span>(<span>lst, x=0, y=-1, want=None, cohen=0.2, enough=0.2, trivial=0.05)</span>
</code></dt>
<dd>
<div class="desc"><p>BINS: return ranges for columns of numbers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numbins(lst, x=0, y=-1, want=None,
            cohen=.2, enough=.2, trivial=.05):
  &#34;BINS: return ranges for columns of numbers.&#34;
  def run1(z=&#34;__all__&#34;):
    &#34;Splits have these slots.&#34;
    return o(xlo=z, xhi=z, x=x, ys=o(), val=0)

  def split(xlo=0, runs=[run1(0)]):
    &#34;Split a long list into a few bins.&#34;
    n = len(lst)**enough
    while n &lt; 10 and n &lt; len(lst) / 2:
      n *= 1.2
    for xhi, z in enumerate(lst):
      if xhi - xlo &gt;= n:  # split when big enough
        if len(lst) - xhi &gt;= n:  # split when enough remains after
          if z[x] != lst[xhi - 1][x]:  # split when values differ
            runs += [run1(xhi)]
            xlo = xhi
      now = runs[-1]
      now.xhi = xhi + 1
      all.xhi = xhi + 1
      klass = 1 if z[y] == want else 0
      now.ys.inc(klass)
      all.ys.inc(klass)
    return [score(run) for run in runs]

  def merge(runs, j=0, tmp=[]):
    &#34;&#34;&#34;Merge things that are too small to be difference
    or, if we know the goal we want,  if the splits
    aren&#39;t good ways to get to the goal.&#34;&#34;&#34;
    def add(z1, z2):
      return score(o(xlo=z1.xlo, xhi=z2.xhi, x=x,
                     ys=z1.ys + z2.ys, val=0))

    def per(z=0.5):
      return lst[int(len(lst) * z)][x]
    # --------------------------------------
    d = cohen * (per(.9) - per(.1)) / 2.54  # cohen*sd
    while j &lt; len(runs):
      a = runs[j]
      if j &lt; len(runs) - 1:
        b = runs[j + 1]
        ab = add(a, b)
        # split if the difference is too small or splits dont do better for `want`.
        if(per(b) - per(a)) &lt; d or want and ab.val &gt;= a.val and ab.val &gt;= b.val:
          a = ab
          j += 1
      tmp += [a]
      j += 1
    return tmp if len(tmp) == len(runs) else merge(tmp, 0, [])

  def cleanup(z):
    &#34;Final clean up. Replace indexes with values at those indexes.&#34;
    def n(n0): return lst[min(len(lst) - 1, n0)][x]
    z.xlo, z.xhi = n(z.xlo), n(z.xhi)
    return z

  # --------------------------------------------------------------
  lst = sorted((z for z in lst if z[x] != &#34;?&#34;), key=lambda z: z[x])
  all = run1(0)
  return [xplain(run) for run in merge(split())]</code></pre>
</details>
</dd>
<dt id="simp.opt"><code class="name flex">
<span>def <span class="ident">opt</span></span>(<span>d, **tyoes)</span>
</code></dt>
<dd>
<div class="desc"><p>LIB: coerce dictionaries into simple keys
whose values are of known <code>types</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def opt(d, **tyoes):
  &#34;&#34;&#34;LIB: coerce dictionaries into simple keys
  whose values are of known `types`.&#34;&#34;&#34;
  d = {re.sub(r&#34;^[-]+&#34;, &#34;&#34;, k): v for k, v in d.items()}
  for k, f in types.items():
    d[k] = f(d[k])
  return o(**d)</code></pre>
</details>
</dd>
<dt id="simp.pairs"><code class="name flex">
<span>def <span class="ident">pairs</span></span>(<span>lst)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pairs(lst):
  j = 0
  while j &lt; len(lst) - 1:
    yield lst[j], lst[j + 1]
    j += 2</code></pre>
</details>
</dd>
<dt id="simp.random"><code class="name flex">
<span>def <span class="ident">random</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>random() -&gt; x in the interval [0, 1).</p></div>
</dd>
<dt id="simp.rows"><code class="name flex">
<span>def <span class="ident">rows</span></span>(<span>x=None, f=sys.stdin)</span>
</code></dt>
<dd>
<div class="desc"><p>Read from stdio or file or string or list. Kill whitespace or comments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rows(x=None, f=sys.stdin):
  &#34;Read from stdio or file or string or list. Kill whitespace or comments.&#34;
  def items(z):
    for y in z:
      yield y

  def strings(z):
    for y in z.splitlines():
      yield y

  def csv(z):
    with open(z) as fp:
      for y in fp:
        yield y

  if x:
    if isinstance(x, (list, tuple)):
      f = items
    elif x[-3:] == &#39;csv&#39;:
      f = csv
    else:
      f = strings
  for y in f(x):
    if isinstance(y, str):
      y = re.sub(r&#39;([\n\t\r ]|#.*)&#39;, &#39;&#39;, y).strip()
      if y:
        yield y.split()
    else:
      yield y</code></pre>
</details>
</dd>
<dt id="simp.same"><code class="name flex">
<span>def <span class="ident">same</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>LIB: Return <code>x</code>, unaltered.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def same(x):
  &#34;LIB: Return `x`, unaltered.&#34;
  return x</code></pre>
</details>
</dd>
<dt id="simp.score"><code class="name flex">
<span>def <span class="ident">score</span></span>(<span>z, all, e=1e-05)</span>
</code></dt>
<dd>
<div class="desc"><p>Score a bin by prob*support that it selects for the goal.
If too small, set to zero.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def score(z, all, e=0.00001):
  &#34;&#34;&#34;
  Score a bin by prob*support that it selects for the goal.
  If too small, set to zero.
  &#34;&#34;&#34;
  yes = z.ys.d.get(1, 0) / (all.ys.d.get(1, 0) + e)
  no = z.ys.d.get(0, 0) / (all.ys.d.get(0, 0) + e)
  tmp = yes**2 / (yes + no + e)
  z.val = tmp if tmp &gt; 0.01 else 0
  return z</code></pre>
</details>
</dd>
<dt id="simp.shuffle"><code class="name flex">
<span>def <span class="ident">shuffle</span></span>(<span>a)</span>
</code></dt>
<dd>
<div class="desc"><p>LIB: return a randomly shuffled list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shuffle(a):
  &#34;LIB: return a randomly shuffled list.&#34;
  rshuffle(a)
  return a</code></pre>
</details>
</dd>
<dt id="simp.smo"><code class="name flex">
<span>def <span class="ident">smo</span></span>(<span>tab, n1=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smo(tab, n1=10):
  lst = shuffle(tab.rows)
  for i, j in pairs(lst[:n1]):
    i.dom += i.better(j)</code></pre>
</details>
</dd>
<dt id="simp.symbins"><code class="name flex">
<span>def <span class="ident">symbins</span></span>(<span>lst, x=0, y=-1, want=None, *_)</span>
</code></dt>
<dd>
<div class="desc"><p>BINS: return ranges for columns of symbols.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def symbins(lst, x=0, y=-1, want=None, *_):
  &#34;BINS: return ranges for columns of symbols.&#34;
  def run1(z=&#34;__all__&#34;):
    return o(xlo=z, xhi=z, x=x, ys=o(), val=0)
  all = run1()
  bins = {}
  for z in lst:
    xx, yy = z[x], z[y]
    if xx != &#34;?&#34;:
      if xx not in bins:
        bins[xx] = run1(xx)
      one = bins[xx]
      klass = 1 if yy == want else 0
      one.ys.inc(klass)
      all.ys.inc(klass)
  return [score(one, all) for one in bins.values()]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="simp.Row"><code class="flex name class">
<span>class <span class="ident">Row</span></span>
<span>(</span><span>tab, cells)</span>
</code></dt>
<dd>
<div class="desc"><p>TABLE: holds one example from a table <code>_tab</code>
in 'cells' (and, if the row has been descretized,
in 'bins').</p>
<p>New item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Row(o):
  &#34;&#34;&#34;
  TABLE: holds one example from a table `_tab`
  in &#39;cells&#39; (and, if the row has been descretized,
  in &#39;bins&#39;).
  &#34;&#34;&#34;
  def __init__(i, tab, cells):
    i._tab = tab
    i.cells = cells
    i.bins = cells[:]
    i.seen = False
    i.dom = 0

  def __getitem__(i, k):
    return i.cells[k]

  def better(i, j):
    c = i._tab.cols
    s1, s2, n = 0, 0, len(c.y) + 0.0001
    for k in c.y:
      x = i.bins[k]
      y = j.bins[k]
      s1 -= math.e**(c.w[k] * (x - y) / n)
      s2 -= math.e**(c.w[k] * (y - x) / n)
    return s1 / n &lt; s2 / n

  def dist(i, j, what=&#34;x&#34;):
    d, n = 0, 0
    for c in i._tab.cols[what]:
      a, b = i.cells[c], j.cells[c]
      n += 1
      if a == &#34;?&#34; and b == &#34;?&#34;:
        d = 1
      else:
        if a == &#34;?&#34;:
          a = 0 if b &gt; 0.5 else 1
        if b == &#34;?&#34;:
          b = 0 if a &gt; 0.5 else 1
      d += abs(a - b) ^ 2
    return (d / (n + 0.001))**0.5

  def status(i):
    return [i[y] for y in i._tab.cols.y]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="simp.o" href="#simp.o">o</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="simp.Row.better"><code class="name flex">
<span>def <span class="ident">better</span></span>(<span>i, j)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def better(i, j):
  c = i._tab.cols
  s1, s2, n = 0, 0, len(c.y) + 0.0001
  for k in c.y:
    x = i.bins[k]
    y = j.bins[k]
    s1 -= math.e**(c.w[k] * (x - y) / n)
    s2 -= math.e**(c.w[k] * (y - x) / n)
  return s1 / n &lt; s2 / n</code></pre>
</details>
</dd>
<dt id="simp.Row.dist"><code class="name flex">
<span>def <span class="ident">dist</span></span>(<span>i, j, what='x')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dist(i, j, what=&#34;x&#34;):
  d, n = 0, 0
  for c in i._tab.cols[what]:
    a, b = i.cells[c], j.cells[c]
    n += 1
    if a == &#34;?&#34; and b == &#34;?&#34;:
      d = 1
    else:
      if a == &#34;?&#34;:
        a = 0 if b &gt; 0.5 else 1
      if b == &#34;?&#34;:
        b = 0 if a &gt; 0.5 else 1
    d += abs(a - b) ^ 2
  return (d / (n + 0.001))**0.5</code></pre>
</details>
</dd>
<dt id="simp.Row.status"><code class="name flex">
<span>def <span class="ident">status</span></span>(<span>i)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def status(i):
  return [i[y] for y in i._tab.cols.y]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="simp.o" href="#simp.o">o</a></b></code>:
<ul class="hlist">
<li><code><a title="simp.o.d" href="#simp.o.d">d</a></code></li>
<li><code><a title="simp.o.inc" href="#simp.o.inc">inc</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="simp.Tab"><code class="flex name class">
<span>class <span class="ident">Tab</span></span>
<span>(</span><span>src=[])</span>
</code></dt>
<dd>
<div class="desc"><p>TABLE:
holds many examples in <code><a title="simp.rows" href="#simp.rows">rows()</a></code>.
Also, <code><a title="simp.cols" href="#simp.cols">cols()</a></code> stores
type descriptions for each column (and <code><a title="simp.cols" href="#simp.cols">cols()</a></code> is built from the
names in the first row).</p>
<p>Create from <code>src</code>, which could be a list,
a <code>.csv</code> file name, or a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tab(o):
  &#34;&#34;&#34;
  TABLE:  holds many examples in `rows`.  Also, `cols` stores
  type descriptions for each column (and `cols` is built from the
  names in the first row).
  &#34;&#34;&#34;
  def __init__(i, src=[]):
    &#34;&#34;&#34;
    Create from `src`, which could be a list,
    a `.csv` file name, or a string.
    &#34;&#34;&#34;
    i.rows = []
    i.cols = o(all={}, w={}, klass=None, x={}, y={}, syms={}, nums={})
    i._bins = {}
    [i.add(row) for row in cols(rows(src))]

  def add(i, row):
    &#34;The first `row` goes to the header. All the rest got to `rows`.&#34;
    i.row(row) if i.cols.all else i.header(row)

  ch = o(klass=&#34;!&#34;, num=&#34;$&#34;,
         less=&#34;&lt;&#34;, more=&#34;&gt;&#34;, skip=&#34;?&#34;,
         nums=&#34;&gt;&lt;$&#34;, goal=&#34;&lt;&gt;!,&#34;)

  def header(i, lst):
    &#34;&#34;&#34;
    Using the magic characters from `Tab.ch`, divide the columns
    into the symbols, the numbers, the x cols, the y cols, the
    klass col. Also, store them all in the `all` list.
    &#34;&#34;&#34;
    c, ch = i.cols, Tab.ch
    c.klass = -1
    for pos, txt in enumerate(lst):
      c.all[pos] = txt
      (c.nums if txt[0] in ch.nums else c.syms)[pos] = txt
      (c.y if txt[0] in ch.goal else c.x)[pos] = txt
      c.w[pos] = -1 if ch.less in txt else 1
      if ch.klass in txt:
        c.klass = pos

  def row(i, lst):
    i.rows += [Row(i, lst)]

  def bins(i, goal=None, cohen=.2):
    &#34;&#34;&#34;
    Divide numerics into  ranges that best select for `goal`.  If
    `goal=None` then just divide into sqrt(N) bins, that differ
    by more than a small amount (at least `.2*sd`).
    &#34;&#34;&#34;
    def appy(runs, x):
      if x == &#34;?&#34;:
        return x
      n = len(runs)
      for pos, run in enumerate(runs):
        # print(x, run.xlo)
        if x &lt; run.xlo:
          break
        if run.xlo &lt;= x &lt; run.xhi:
          break
      return round((pos + 1) / n, 2)
    # ----------------
    for x in i.cols.nums:
      # find the bins
      i._bins[x] = bins = numbins(
          i.rows, want=want, x=x, goal=goal, cohen=cohen,
          y=i.cols.klass)
      # apply the bins
      for row in i.rows:
        row.bins[x] = appy(bins, row[x])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="simp.o" href="#simp.o">o</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="simp.Tab.ch"><code class="name">var <span class="ident">ch</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="simp.Tab.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>i, row)</span>
</code></dt>
<dd>
<div class="desc"><p>The first <code>row</code> goes to the header. All the rest got to <code><a title="simp.rows" href="#simp.rows">rows()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(i, row):
  &#34;The first `row` goes to the header. All the rest got to `rows`.&#34;
  i.row(row) if i.cols.all else i.header(row)</code></pre>
</details>
</dd>
<dt id="simp.Tab.bins"><code class="name flex">
<span>def <span class="ident">bins</span></span>(<span>i, goal=None, cohen=0.2)</span>
</code></dt>
<dd>
<div class="desc"><p>Divide numerics into
ranges that best select for <code>goal</code>.
If
<code>goal=None</code> then just divide into sqrt(N) bins, that differ
by more than a small amount (at least <code>.2*sd</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bins(i, goal=None, cohen=.2):
  &#34;&#34;&#34;
  Divide numerics into  ranges that best select for `goal`.  If
  `goal=None` then just divide into sqrt(N) bins, that differ
  by more than a small amount (at least `.2*sd`).
  &#34;&#34;&#34;
  def appy(runs, x):
    if x == &#34;?&#34;:
      return x
    n = len(runs)
    for pos, run in enumerate(runs):
      # print(x, run.xlo)
      if x &lt; run.xlo:
        break
      if run.xlo &lt;= x &lt; run.xhi:
        break
    return round((pos + 1) / n, 2)
  # ----------------
  for x in i.cols.nums:
    # find the bins
    i._bins[x] = bins = numbins(
        i.rows, want=want, x=x, goal=goal, cohen=cohen,
        y=i.cols.klass)
    # apply the bins
    for row in i.rows:
      row.bins[x] = appy(bins, row[x])</code></pre>
</details>
</dd>
<dt id="simp.Tab.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>i, lst)</span>
</code></dt>
<dd>
<div class="desc"><p>Using the magic characters from <code><a title="simp.Tab.ch" href="#simp.Tab.ch">Tab.ch</a></code>, divide the columns
into the symbols, the numbers, the x cols, the y cols, the
klass col. Also, store them all in the <code>all</code> list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(i, lst):
  &#34;&#34;&#34;
  Using the magic characters from `Tab.ch`, divide the columns
  into the symbols, the numbers, the x cols, the y cols, the
  klass col. Also, store them all in the `all` list.
  &#34;&#34;&#34;
  c, ch = i.cols, Tab.ch
  c.klass = -1
  for pos, txt in enumerate(lst):
    c.all[pos] = txt
    (c.nums if txt[0] in ch.nums else c.syms)[pos] = txt
    (c.y if txt[0] in ch.goal else c.x)[pos] = txt
    c.w[pos] = -1 if ch.less in txt else 1
    if ch.klass in txt:
      c.klass = pos</code></pre>
</details>
</dd>
<dt id="simp.Tab.row"><code class="name flex">
<span>def <span class="ident">row</span></span>(<span>i, lst)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def row(i, lst):
  i.rows += [Row(i, lst)]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="simp.o" href="#simp.o">o</a></b></code>:
<ul class="hlist">
<li><code><a title="simp.o.d" href="#simp.o.d">d</a></code></li>
<li><code><a title="simp.o.inc" href="#simp.o.inc">inc</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="simp.o"><code class="flex name class">
<span>class <span class="ident">o</span></span>
<span>(</span><span>**d)</span>
</code></dt>
<dd>
<div class="desc"><p>LIB: Class that can pretty print; that
can <code>inc</code>rement and <code>__add__</code> their values.</p>
<p>New item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class o:
  &#34;&#34;&#34;LIB: Class that can pretty print; that
  can `inc`rement and `__add__` their values.&#34;&#34;&#34;
  def __init__(i, **d):
    &#34;New item.&#34;
    i.d.update(**d)

  @property
  def d(i):
    &#34;Return the internal dictionary.&#34;
    return i.__dict__

  def __repr__(i):
    &#34;Pretty print. Hide private keys (those starting in `_`)&#34;
    n = i.__class__.__name__
    return n + &#34;{&#34; + &#39;, &#39;.join(
        [(&#39;:%s %s&#39; % (k, i.d[k])) for k in sorted(i.d.keys())
            if str(k)[0] != &#34;_&#34;]) + &#34;}&#34;

  def inc(i, x):
    &#34;Increment `x` (starting at zero)&#34;
    i.d[x] = i.d.get(x, 0) + 1

  def __add__(i, j):
    &#34;Add together the numeric values in `i` and `j`.&#34;
    k = o()
    for x, v in i.d.items():
      k[x] = v
    for x, v in j.d.items():
      k.d[x] = v + k.d.get(x, 0)
    return k</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="simp.Row" href="#simp.Row">Row</a></li>
<li><a title="simp.Tab" href="#simp.Tab">Tab</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="simp.o.d"><code class="name">var <span class="ident">d</span></code></dt>
<dd>
<div class="desc"><p>Return the internal dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def d(i):
  &#34;Return the internal dictionary.&#34;
  return i.__dict__</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="simp.o.inc"><code class="name flex">
<span>def <span class="ident">inc</span></span>(<span>i, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Increment <code>x</code> (starting at zero)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inc(i, x):
  &#34;Increment `x` (starting at zero)&#34;
  i.d[x] = i.d.get(x, 0) + 1</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="simp.cols" href="#simp.cols">cols</a></code></li>
<li><code><a title="simp.first" href="#simp.first">first</a></code></li>
<li><code><a title="simp.last" href="#simp.last">last</a></code></li>
<li><code><a title="simp.numbins" href="#simp.numbins">numbins</a></code></li>
<li><code><a title="simp.opt" href="#simp.opt">opt</a></code></li>
<li><code><a title="simp.pairs" href="#simp.pairs">pairs</a></code></li>
<li><code><a title="simp.random" href="#simp.random">random</a></code></li>
<li><code><a title="simp.rows" href="#simp.rows">rows</a></code></li>
<li><code><a title="simp.same" href="#simp.same">same</a></code></li>
<li><code><a title="simp.score" href="#simp.score">score</a></code></li>
<li><code><a title="simp.shuffle" href="#simp.shuffle">shuffle</a></code></li>
<li><code><a title="simp.smo" href="#simp.smo">smo</a></code></li>
<li><code><a title="simp.symbins" href="#simp.symbins">symbins</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="simp.Row" href="#simp.Row">Row</a></code></h4>
<ul class="">
<li><code><a title="simp.Row.better" href="#simp.Row.better">better</a></code></li>
<li><code><a title="simp.Row.dist" href="#simp.Row.dist">dist</a></code></li>
<li><code><a title="simp.Row.status" href="#simp.Row.status">status</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simp.Tab" href="#simp.Tab">Tab</a></code></h4>
<ul class="">
<li><code><a title="simp.Tab.add" href="#simp.Tab.add">add</a></code></li>
<li><code><a title="simp.Tab.bins" href="#simp.Tab.bins">bins</a></code></li>
<li><code><a title="simp.Tab.ch" href="#simp.Tab.ch">ch</a></code></li>
<li><code><a title="simp.Tab.header" href="#simp.Tab.header">header</a></code></li>
<li><code><a title="simp.Tab.row" href="#simp.Tab.row">row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="simp.o" href="#simp.o">o</a></code></h4>
<ul class="">
<li><code><a title="simp.o.d" href="#simp.o.d">d</a></code></li>
<li><code><a title="simp.o.inc" href="#simp.o.inc">inc</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>